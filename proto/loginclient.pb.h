// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loginclient.proto

#ifndef PROTOBUF_loginclient_2eproto__INCLUDED
#define PROTOBUF_loginclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)

namespace protoc {
namespace loginclient {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_loginclient_2eproto();
void protobuf_AssignDesc_loginclient_2eproto();
void protobuf_ShutdownFile_loginclient_2eproto();

class ClientLoginReq;
class ClientLoginAck;
class ClientCreateAccountReq;
class ClientCreateAccountAck;
class ClientWebLoginReq;
class OnePlayerInfo;
class AccountAllPlayerInfoRpt;
class SelectActivePlayer;
class WaitingLoinNtf;
class SelfModeCreatekAccountReq;
class SelfModeCreatekAccountAck;
class SelfModeActiveAccountReq;
class SelfModeActiveAccountAck;

// ===================================================================

class ClientLoginReq : public ::google::protobuf::Message {
 public:
  ClientLoginReq();
  virtual ~ClientLoginReq();

  ClientLoginReq(const ClientLoginReq& from);

  inline ClientLoginReq& operator=(const ClientLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLoginReq& default_instance();

  void Swap(ClientLoginReq* other);

  // implements Message ----------------------------------------------

  ClientLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLoginReq& from);
  void MergeFrom(const ClientLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional int32 opt = 4;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 4;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // optional string login_key = 5;
  inline bool has_login_key() const;
  inline void clear_login_key();
  static const int kLoginKeyFieldNumber = 5;
  inline const ::std::string& login_key() const;
  inline void set_login_key(const ::std::string& value);
  inline void set_login_key(const char* value);
  inline void set_login_key(const char* value, size_t size);
  inline ::std::string* mutable_login_key();
  inline ::std::string* release_login_key();
  inline void set_allocated_login_key(::std::string* login_key);

  // optional uint32 version_id = 6;
  inline bool has_version_id() const;
  inline void clear_version_id();
  static const int kVersionIdFieldNumber = 6;
  inline ::google::protobuf::uint32 version_id() const;
  inline void set_version_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.ClientLoginReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_opt();
  inline void clear_has_opt();
  inline void set_has_login_key();
  inline void clear_has_login_key();
  inline void set_has_version_id();
  inline void clear_has_version_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::std::string* session_key_;
  ::std::string* login_key_;
  ::google::protobuf::int32 opt_;
  ::google::protobuf::uint32 version_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static ClientLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class ClientLoginAck : public ::google::protobuf::Message {
 public:
  ClientLoginAck();
  virtual ~ClientLoginAck();

  ClientLoginAck(const ClientLoginAck& from);

  inline ClientLoginAck& operator=(const ClientLoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLoginAck& default_instance();

  void Swap(ClientLoginAck* other);

  // implements Message ----------------------------------------------

  ClientLoginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLoginAck& from);
  void MergeFrom(const ClientLoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional string gate_ip = 2;
  inline bool has_gate_ip() const;
  inline void clear_gate_ip();
  static const int kGateIpFieldNumber = 2;
  inline const ::std::string& gate_ip() const;
  inline void set_gate_ip(const ::std::string& value);
  inline void set_gate_ip(const char* value);
  inline void set_gate_ip(const char* value, size_t size);
  inline ::std::string* mutable_gate_ip();
  inline ::std::string* release_gate_ip();
  inline void set_allocated_gate_ip(::std::string* gate_ip);

  // optional uint32 gate_port = 3;
  inline bool has_gate_port() const;
  inline void clear_gate_port();
  static const int kGatePortFieldNumber = 3;
  inline ::google::protobuf::uint32 gate_port() const;
  inline void set_gate_port(::google::protobuf::uint32 value);

  // optional int32 gate_key = 4;
  inline bool has_gate_key() const;
  inline void clear_gate_key();
  static const int kGateKeyFieldNumber = 4;
  inline ::google::protobuf::int32 gate_key() const;
  inline void set_gate_key(::google::protobuf::int32 value);

  // optional int32 err_no = 5;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 5;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string error_msg = 6;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 6;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // optional string account = 7;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 7;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.ClientLoginAck)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_gate_ip();
  inline void clear_has_gate_ip();
  inline void set_has_gate_port();
  inline void clear_has_gate_port();
  inline void set_has_gate_key();
  inline void clear_has_gate_key();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* gate_ip_;
  ::google::protobuf::uint32 gate_port_;
  ::google::protobuf::int32 gate_key_;
  ::std::string* error_msg_;
  ::std::string* account_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static ClientLoginAck* default_instance_;
};
// -------------------------------------------------------------------

class ClientCreateAccountReq : public ::google::protobuf::Message {
 public:
  ClientCreateAccountReq();
  virtual ~ClientCreateAccountReq();

  ClientCreateAccountReq(const ClientCreateAccountReq& from);

  inline ClientCreateAccountReq& operator=(const ClientCreateAccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCreateAccountReq& default_instance();

  void Swap(ClientCreateAccountReq* other);

  // implements Message ----------------------------------------------

  ClientCreateAccountReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCreateAccountReq& from);
  void MergeFrom(const ClientCreateAccountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional int32 opt = 4;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 4;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.ClientCreateAccountReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::std::string* session_key_;
  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static ClientCreateAccountReq* default_instance_;
};
// -------------------------------------------------------------------

class ClientCreateAccountAck : public ::google::protobuf::Message {
 public:
  ClientCreateAccountAck();
  virtual ~ClientCreateAccountAck();

  ClientCreateAccountAck(const ClientCreateAccountAck& from);

  inline ClientCreateAccountAck& operator=(const ClientCreateAccountAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCreateAccountAck& default_instance();

  void Swap(ClientCreateAccountAck* other);

  // implements Message ----------------------------------------------

  ClientCreateAccountAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCreateAccountAck& from);
  void MergeFrom(const ClientCreateAccountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint64 opt = 3;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 3;
  inline ::google::protobuf::uint64 opt() const;
  inline void set_opt(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.ClientCreateAccountAck)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::uint64 opt_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static ClientCreateAccountAck* default_instance_;
};
// -------------------------------------------------------------------

class ClientWebLoginReq : public ::google::protobuf::Message {
 public:
  ClientWebLoginReq();
  virtual ~ClientWebLoginReq();

  ClientWebLoginReq(const ClientWebLoginReq& from);

  inline ClientWebLoginReq& operator=(const ClientWebLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientWebLoginReq& default_instance();

  void Swap(ClientWebLoginReq* other);

  // implements Message ----------------------------------------------

  ClientWebLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientWebLoginReq& from);
  void MergeFrom(const ClientWebLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string session_key = 1;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 1;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 version_id = 3;
  inline bool has_version_id() const;
  inline void clear_version_id();
  static const int kVersionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 version_id() const;
  inline void set_version_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.ClientWebLoginReq)
 private:
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_version_id();
  inline void clear_has_version_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* session_key_;
  ::std::string* account_;
  ::google::protobuf::uint32 version_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static ClientWebLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class OnePlayerInfo : public ::google::protobuf::Message {
 public:
  OnePlayerInfo();
  virtual ~OnePlayerInfo();

  OnePlayerInfo(const OnePlayerInfo& from);

  inline OnePlayerInfo& operator=(const OnePlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnePlayerInfo& default_instance();

  void Swap(OnePlayerInfo* other);

  // implements Message ----------------------------------------------

  OnePlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnePlayerInfo& from);
  void MergeFrom(const OnePlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digitid = 1;
  inline bool has_digitid() const;
  inline void clear_digitid();
  static const int kDigitidFieldNumber = 1;
  inline ::google::protobuf::uint64 digitid() const;
  inline void set_digitid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.OnePlayerInfo)
 private:
  inline void set_has_digitid();
  inline void clear_has_digitid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digitid_;
  ::std::string* name_;
  ::google::protobuf::uint32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static OnePlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class AccountAllPlayerInfoRpt : public ::google::protobuf::Message {
 public:
  AccountAllPlayerInfoRpt();
  virtual ~AccountAllPlayerInfoRpt();

  AccountAllPlayerInfoRpt(const AccountAllPlayerInfoRpt& from);

  inline AccountAllPlayerInfoRpt& operator=(const AccountAllPlayerInfoRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountAllPlayerInfoRpt& default_instance();

  void Swap(AccountAllPlayerInfoRpt* other);

  // implements Message ----------------------------------------------

  AccountAllPlayerInfoRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountAllPlayerInfoRpt& from);
  void MergeFrom(const AccountAllPlayerInfoRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protoc.loginclient.OnePlayerInfo players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::protoc::loginclient::OnePlayerInfo& players(int index) const;
  inline ::protoc::loginclient::OnePlayerInfo* mutable_players(int index);
  inline ::protoc::loginclient::OnePlayerInfo* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::protoc::loginclient::OnePlayerInfo >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoc::loginclient::OnePlayerInfo >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:protoc.loginclient.AccountAllPlayerInfoRpt)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protoc::loginclient::OnePlayerInfo > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static AccountAllPlayerInfoRpt* default_instance_;
};
// -------------------------------------------------------------------

class SelectActivePlayer : public ::google::protobuf::Message {
 public:
  SelectActivePlayer();
  virtual ~SelectActivePlayer();

  SelectActivePlayer(const SelectActivePlayer& from);

  inline SelectActivePlayer& operator=(const SelectActivePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectActivePlayer& default_instance();

  void Swap(SelectActivePlayer* other);

  // implements Message ----------------------------------------------

  SelectActivePlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelectActivePlayer& from);
  void MergeFrom(const SelectActivePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digitid = 1;
  inline bool has_digitid() const;
  inline void clear_digitid();
  static const int kDigitidFieldNumber = 1;
  inline ::google::protobuf::uint64 digitid() const;
  inline void set_digitid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.SelectActivePlayer)
 private:
  inline void set_has_digitid();
  inline void clear_has_digitid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digitid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static SelectActivePlayer* default_instance_;
};
// -------------------------------------------------------------------

class WaitingLoinNtf : public ::google::protobuf::Message {
 public:
  WaitingLoinNtf();
  virtual ~WaitingLoinNtf();

  WaitingLoinNtf(const WaitingLoinNtf& from);

  inline WaitingLoinNtf& operator=(const WaitingLoinNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitingLoinNtf& default_instance();

  void Swap(WaitingLoinNtf* other);

  // implements Message ----------------------------------------------

  WaitingLoinNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WaitingLoinNtf& from);
  void MergeFrom(const WaitingLoinNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.WaitingLoinNtf)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static WaitingLoinNtf* default_instance_;
};
// -------------------------------------------------------------------

class SelfModeCreatekAccountReq : public ::google::protobuf::Message {
 public:
  SelfModeCreatekAccountReq();
  virtual ~SelfModeCreatekAccountReq();

  SelfModeCreatekAccountReq(const SelfModeCreatekAccountReq& from);

  inline SelfModeCreatekAccountReq& operator=(const SelfModeCreatekAccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelfModeCreatekAccountReq& default_instance();

  void Swap(SelfModeCreatekAccountReq* other);

  // implements Message ----------------------------------------------

  SelfModeCreatekAccountReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelfModeCreatekAccountReq& from);
  void MergeFrom(const SelfModeCreatekAccountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string invitation_code = 3;
  inline bool has_invitation_code() const;
  inline void clear_invitation_code();
  static const int kInvitationCodeFieldNumber = 3;
  inline const ::std::string& invitation_code() const;
  inline void set_invitation_code(const ::std::string& value);
  inline void set_invitation_code(const char* value);
  inline void set_invitation_code(const char* value, size_t size);
  inline ::std::string* mutable_invitation_code();
  inline ::std::string* release_invitation_code();
  inline void set_allocated_invitation_code(::std::string* invitation_code);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.SelfModeCreatekAccountReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_invitation_code();
  inline void clear_has_invitation_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::std::string* invitation_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static SelfModeCreatekAccountReq* default_instance_;
};
// -------------------------------------------------------------------

class SelfModeCreatekAccountAck : public ::google::protobuf::Message {
 public:
  SelfModeCreatekAccountAck();
  virtual ~SelfModeCreatekAccountAck();

  SelfModeCreatekAccountAck(const SelfModeCreatekAccountAck& from);

  inline SelfModeCreatekAccountAck& operator=(const SelfModeCreatekAccountAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelfModeCreatekAccountAck& default_instance();

  void Swap(SelfModeCreatekAccountAck* other);

  // implements Message ----------------------------------------------

  SelfModeCreatekAccountAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelfModeCreatekAccountAck& from);
  void MergeFrom(const SelfModeCreatekAccountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.SelfModeCreatekAccountAck)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static SelfModeCreatekAccountAck* default_instance_;
};
// -------------------------------------------------------------------

class SelfModeActiveAccountReq : public ::google::protobuf::Message {
 public:
  SelfModeActiveAccountReq();
  virtual ~SelfModeActiveAccountReq();

  SelfModeActiveAccountReq(const SelfModeActiveAccountReq& from);

  inline SelfModeActiveAccountReq& operator=(const SelfModeActiveAccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelfModeActiveAccountReq& default_instance();

  void Swap(SelfModeActiveAccountReq* other);

  // implements Message ----------------------------------------------

  SelfModeActiveAccountReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelfModeActiveAccountReq& from);
  void MergeFrom(const SelfModeActiveAccountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string invitation_code = 2;
  inline bool has_invitation_code() const;
  inline void clear_invitation_code();
  static const int kInvitationCodeFieldNumber = 2;
  inline const ::std::string& invitation_code() const;
  inline void set_invitation_code(const ::std::string& value);
  inline void set_invitation_code(const char* value);
  inline void set_invitation_code(const char* value, size_t size);
  inline ::std::string* mutable_invitation_code();
  inline ::std::string* release_invitation_code();
  inline void set_allocated_invitation_code(::std::string* invitation_code);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.SelfModeActiveAccountReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_invitation_code();
  inline void clear_has_invitation_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* invitation_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static SelfModeActiveAccountReq* default_instance_;
};
// -------------------------------------------------------------------

class SelfModeActiveAccountAck : public ::google::protobuf::Message {
 public:
  SelfModeActiveAccountAck();
  virtual ~SelfModeActiveAccountAck();

  SelfModeActiveAccountAck(const SelfModeActiveAccountAck& from);

  inline SelfModeActiveAccountAck& operator=(const SelfModeActiveAccountAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelfModeActiveAccountAck& default_instance();

  void Swap(SelfModeActiveAccountAck* other);

  // implements Message ----------------------------------------------

  SelfModeActiveAccountAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelfModeActiveAccountAck& from);
  void MergeFrom(const SelfModeActiveAccountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.loginclient.SelfModeActiveAccountAck)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginclient_2eproto();
  friend void protobuf_AssignDesc_loginclient_2eproto();
  friend void protobuf_ShutdownFile_loginclient_2eproto();

  void InitAsDefaultInstance();
  static SelfModeActiveAccountAck* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientLoginReq

// required string account = 1;
inline bool ClientLoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientLoginReq::account() const {
  return *account_;
}
inline void ClientLoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientLoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientLoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientLoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool ClientLoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientLoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientLoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientLoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ClientLoginReq::password() const {
  return *password_;
}
inline void ClientLoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientLoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientLoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ClientLoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_key = 3;
inline bool ClientLoginReq::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientLoginReq::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientLoginReq::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientLoginReq::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& ClientLoginReq::session_key() const {
  return *session_key_;
}
inline void ClientLoginReq::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientLoginReq::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientLoginReq::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginReq::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* ClientLoginReq::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginReq::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 opt = 4;
inline bool ClientLoginReq::has_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientLoginReq::set_has_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientLoginReq::clear_has_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientLoginReq::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 ClientLoginReq::opt() const {
  return opt_;
}
inline void ClientLoginReq::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// optional string login_key = 5;
inline bool ClientLoginReq::has_login_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientLoginReq::set_has_login_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientLoginReq::clear_has_login_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientLoginReq::clear_login_key() {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    login_key_->clear();
  }
  clear_has_login_key();
}
inline const ::std::string& ClientLoginReq::login_key() const {
  return *login_key_;
}
inline void ClientLoginReq::set_login_key(const ::std::string& value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void ClientLoginReq::set_login_key(const char* value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void ClientLoginReq::set_login_key(const char* value, size_t size) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginReq::mutable_login_key() {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  return login_key_;
}
inline ::std::string* ClientLoginReq::release_login_key() {
  clear_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_key_;
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginReq::set_allocated_login_key(::std::string* login_key) {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    delete login_key_;
  }
  if (login_key) {
    set_has_login_key();
    login_key_ = login_key;
  } else {
    clear_has_login_key();
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version_id = 6;
inline bool ClientLoginReq::has_version_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientLoginReq::set_has_version_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientLoginReq::clear_has_version_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientLoginReq::clear_version_id() {
  version_id_ = 0u;
  clear_has_version_id();
}
inline ::google::protobuf::uint32 ClientLoginReq::version_id() const {
  return version_id_;
}
inline void ClientLoginReq::set_version_id(::google::protobuf::uint32 value) {
  set_has_version_id();
  version_id_ = value;
}

// -------------------------------------------------------------------

// ClientLoginAck

// optional uint64 digit_account = 1;
inline bool ClientLoginAck::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLoginAck::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLoginAck::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLoginAck::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 ClientLoginAck::digit_account() const {
  return digit_account_;
}
inline void ClientLoginAck::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional string gate_ip = 2;
inline bool ClientLoginAck::has_gate_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientLoginAck::set_has_gate_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientLoginAck::clear_has_gate_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientLoginAck::clear_gate_ip() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    gate_ip_->clear();
  }
  clear_has_gate_ip();
}
inline const ::std::string& ClientLoginAck::gate_ip() const {
  return *gate_ip_;
}
inline void ClientLoginAck::set_gate_ip(const ::std::string& value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void ClientLoginAck::set_gate_ip(const char* value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void ClientLoginAck::set_gate_ip(const char* value, size_t size) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginAck::mutable_gate_ip() {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  return gate_ip_;
}
inline ::std::string* ClientLoginAck::release_gate_ip() {
  clear_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_ip_;
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginAck::set_allocated_gate_ip(::std::string* gate_ip) {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  if (gate_ip) {
    set_has_gate_ip();
    gate_ip_ = gate_ip;
  } else {
    clear_has_gate_ip();
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gate_port = 3;
inline bool ClientLoginAck::has_gate_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientLoginAck::set_has_gate_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientLoginAck::clear_has_gate_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientLoginAck::clear_gate_port() {
  gate_port_ = 0u;
  clear_has_gate_port();
}
inline ::google::protobuf::uint32 ClientLoginAck::gate_port() const {
  return gate_port_;
}
inline void ClientLoginAck::set_gate_port(::google::protobuf::uint32 value) {
  set_has_gate_port();
  gate_port_ = value;
}

// optional int32 gate_key = 4;
inline bool ClientLoginAck::has_gate_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientLoginAck::set_has_gate_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientLoginAck::clear_has_gate_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientLoginAck::clear_gate_key() {
  gate_key_ = 0;
  clear_has_gate_key();
}
inline ::google::protobuf::int32 ClientLoginAck::gate_key() const {
  return gate_key_;
}
inline void ClientLoginAck::set_gate_key(::google::protobuf::int32 value) {
  set_has_gate_key();
  gate_key_ = value;
}

// optional int32 err_no = 5;
inline bool ClientLoginAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientLoginAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientLoginAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientLoginAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 ClientLoginAck::err_no() const {
  return err_no_;
}
inline void ClientLoginAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string error_msg = 6;
inline bool ClientLoginAck::has_error_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientLoginAck::set_has_error_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientLoginAck::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientLoginAck::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& ClientLoginAck::error_msg() const {
  return *error_msg_;
}
inline void ClientLoginAck::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void ClientLoginAck::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void ClientLoginAck::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginAck::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* ClientLoginAck::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginAck::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 7;
inline bool ClientLoginAck::has_account() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientLoginAck::set_has_account() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientLoginAck::clear_has_account() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientLoginAck::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientLoginAck::account() const {
  return *account_;
}
inline void ClientLoginAck::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientLoginAck::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientLoginAck::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLoginAck::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientLoginAck::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLoginAck::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientCreateAccountReq

// required string account = 1;
inline bool ClientCreateAccountReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCreateAccountReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCreateAccountReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCreateAccountReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientCreateAccountReq::account() const {
  return *account_;
}
inline void ClientCreateAccountReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientCreateAccountReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientCreateAccountReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientCreateAccountReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientCreateAccountReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientCreateAccountReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool ClientCreateAccountReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCreateAccountReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCreateAccountReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCreateAccountReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ClientCreateAccountReq::password() const {
  return *password_;
}
inline void ClientCreateAccountReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientCreateAccountReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ClientCreateAccountReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientCreateAccountReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ClientCreateAccountReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientCreateAccountReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_key = 3;
inline bool ClientCreateAccountReq::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCreateAccountReq::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientCreateAccountReq::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientCreateAccountReq::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& ClientCreateAccountReq::session_key() const {
  return *session_key_;
}
inline void ClientCreateAccountReq::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientCreateAccountReq::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientCreateAccountReq::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientCreateAccountReq::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* ClientCreateAccountReq::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientCreateAccountReq::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 opt = 4;
inline bool ClientCreateAccountReq::has_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientCreateAccountReq::set_has_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientCreateAccountReq::clear_has_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientCreateAccountReq::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 ClientCreateAccountReq::opt() const {
  return opt_;
}
inline void ClientCreateAccountReq::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// ClientCreateAccountAck

// optional int32 err_no = 1;
inline bool ClientCreateAccountAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCreateAccountAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCreateAccountAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCreateAccountAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 ClientCreateAccountAck::err_no() const {
  return err_no_;
}
inline void ClientCreateAccountAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string account = 2;
inline bool ClientCreateAccountAck::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCreateAccountAck::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCreateAccountAck::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCreateAccountAck::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientCreateAccountAck::account() const {
  return *account_;
}
inline void ClientCreateAccountAck::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientCreateAccountAck::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientCreateAccountAck::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientCreateAccountAck::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientCreateAccountAck::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientCreateAccountAck::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 opt = 3;
inline bool ClientCreateAccountAck::has_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCreateAccountAck::set_has_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientCreateAccountAck::clear_has_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientCreateAccountAck::clear_opt() {
  opt_ = GOOGLE_ULONGLONG(0);
  clear_has_opt();
}
inline ::google::protobuf::uint64 ClientCreateAccountAck::opt() const {
  return opt_;
}
inline void ClientCreateAccountAck::set_opt(::google::protobuf::uint64 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// ClientWebLoginReq

// required string session_key = 1;
inline bool ClientWebLoginReq::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientWebLoginReq::set_has_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientWebLoginReq::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientWebLoginReq::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& ClientWebLoginReq::session_key() const {
  return *session_key_;
}
inline void ClientWebLoginReq::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientWebLoginReq::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void ClientWebLoginReq::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientWebLoginReq::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* ClientWebLoginReq::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientWebLoginReq::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool ClientWebLoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientWebLoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientWebLoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientWebLoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientWebLoginReq::account() const {
  return *account_;
}
inline void ClientWebLoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientWebLoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientWebLoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientWebLoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientWebLoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientWebLoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version_id = 3;
inline bool ClientWebLoginReq::has_version_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientWebLoginReq::set_has_version_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientWebLoginReq::clear_has_version_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientWebLoginReq::clear_version_id() {
  version_id_ = 0u;
  clear_has_version_id();
}
inline ::google::protobuf::uint32 ClientWebLoginReq::version_id() const {
  return version_id_;
}
inline void ClientWebLoginReq::set_version_id(::google::protobuf::uint32 value) {
  set_has_version_id();
  version_id_ = value;
}

// -------------------------------------------------------------------

// OnePlayerInfo

// optional uint64 digitid = 1;
inline bool OnePlayerInfo::has_digitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnePlayerInfo::set_has_digitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnePlayerInfo::clear_has_digitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnePlayerInfo::clear_digitid() {
  digitid_ = GOOGLE_ULONGLONG(0);
  clear_has_digitid();
}
inline ::google::protobuf::uint64 OnePlayerInfo::digitid() const {
  return digitid_;
}
inline void OnePlayerInfo::set_digitid(::google::protobuf::uint64 value) {
  set_has_digitid();
  digitid_ = value;
}

// optional string name = 2;
inline bool OnePlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnePlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnePlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnePlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OnePlayerInfo::name() const {
  return *name_;
}
inline void OnePlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OnePlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OnePlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnePlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OnePlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OnePlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 exp = 3;
inline bool OnePlayerInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnePlayerInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnePlayerInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnePlayerInfo::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 OnePlayerInfo::exp() const {
  return exp_;
}
inline void OnePlayerInfo::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// AccountAllPlayerInfoRpt

// repeated .protoc.loginclient.OnePlayerInfo players = 1;
inline int AccountAllPlayerInfoRpt::players_size() const {
  return players_.size();
}
inline void AccountAllPlayerInfoRpt::clear_players() {
  players_.Clear();
}
inline const ::protoc::loginclient::OnePlayerInfo& AccountAllPlayerInfoRpt::players(int index) const {
  return players_.Get(index);
}
inline ::protoc::loginclient::OnePlayerInfo* AccountAllPlayerInfoRpt::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::protoc::loginclient::OnePlayerInfo* AccountAllPlayerInfoRpt::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoc::loginclient::OnePlayerInfo >&
AccountAllPlayerInfoRpt::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoc::loginclient::OnePlayerInfo >*
AccountAllPlayerInfoRpt::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// SelectActivePlayer

// optional uint64 digitid = 1;
inline bool SelectActivePlayer::has_digitid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectActivePlayer::set_has_digitid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectActivePlayer::clear_has_digitid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectActivePlayer::clear_digitid() {
  digitid_ = GOOGLE_ULONGLONG(0);
  clear_has_digitid();
}
inline ::google::protobuf::uint64 SelectActivePlayer::digitid() const {
  return digitid_;
}
inline void SelectActivePlayer::set_digitid(::google::protobuf::uint64 value) {
  set_has_digitid();
  digitid_ = value;
}

// -------------------------------------------------------------------

// WaitingLoinNtf

// optional int32 number = 1;
inline bool WaitingLoinNtf::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitingLoinNtf::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitingLoinNtf::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitingLoinNtf::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 WaitingLoinNtf::number() const {
  return number_;
}
inline void WaitingLoinNtf::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// SelfModeCreatekAccountReq

// optional string account = 1;
inline bool SelfModeCreatekAccountReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelfModeCreatekAccountReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelfModeCreatekAccountReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelfModeCreatekAccountReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SelfModeCreatekAccountReq::account() const {
  return *account_;
}
inline void SelfModeCreatekAccountReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelfModeCreatekAccountReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SelfModeCreatekAccountReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelfModeCreatekAccountReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool SelfModeCreatekAccountReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelfModeCreatekAccountReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelfModeCreatekAccountReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelfModeCreatekAccountReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SelfModeCreatekAccountReq::password() const {
  return *password_;
}
inline void SelfModeCreatekAccountReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelfModeCreatekAccountReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SelfModeCreatekAccountReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelfModeCreatekAccountReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string invitation_code = 3;
inline bool SelfModeCreatekAccountReq::has_invitation_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelfModeCreatekAccountReq::set_has_invitation_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelfModeCreatekAccountReq::clear_has_invitation_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelfModeCreatekAccountReq::clear_invitation_code() {
  if (invitation_code_ != &::google::protobuf::internal::kEmptyString) {
    invitation_code_->clear();
  }
  clear_has_invitation_code();
}
inline const ::std::string& SelfModeCreatekAccountReq::invitation_code() const {
  return *invitation_code_;
}
inline void SelfModeCreatekAccountReq::set_invitation_code(const ::std::string& value) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_invitation_code(const char* value) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(value);
}
inline void SelfModeCreatekAccountReq::set_invitation_code(const char* value, size_t size) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelfModeCreatekAccountReq::mutable_invitation_code() {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  return invitation_code_;
}
inline ::std::string* SelfModeCreatekAccountReq::release_invitation_code() {
  clear_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invitation_code_;
    invitation_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelfModeCreatekAccountReq::set_allocated_invitation_code(::std::string* invitation_code) {
  if (invitation_code_ != &::google::protobuf::internal::kEmptyString) {
    delete invitation_code_;
  }
  if (invitation_code) {
    set_has_invitation_code();
    invitation_code_ = invitation_code;
  } else {
    clear_has_invitation_code();
    invitation_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SelfModeCreatekAccountAck

// optional int32 err_no = 1;
inline bool SelfModeCreatekAccountAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelfModeCreatekAccountAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelfModeCreatekAccountAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelfModeCreatekAccountAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 SelfModeCreatekAccountAck::err_no() const {
  return err_no_;
}
inline void SelfModeCreatekAccountAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// SelfModeActiveAccountReq

// optional string account = 1;
inline bool SelfModeActiveAccountReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelfModeActiveAccountReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelfModeActiveAccountReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelfModeActiveAccountReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SelfModeActiveAccountReq::account() const {
  return *account_;
}
inline void SelfModeActiveAccountReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SelfModeActiveAccountReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SelfModeActiveAccountReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelfModeActiveAccountReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SelfModeActiveAccountReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelfModeActiveAccountReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string invitation_code = 2;
inline bool SelfModeActiveAccountReq::has_invitation_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelfModeActiveAccountReq::set_has_invitation_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelfModeActiveAccountReq::clear_has_invitation_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelfModeActiveAccountReq::clear_invitation_code() {
  if (invitation_code_ != &::google::protobuf::internal::kEmptyString) {
    invitation_code_->clear();
  }
  clear_has_invitation_code();
}
inline const ::std::string& SelfModeActiveAccountReq::invitation_code() const {
  return *invitation_code_;
}
inline void SelfModeActiveAccountReq::set_invitation_code(const ::std::string& value) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(value);
}
inline void SelfModeActiveAccountReq::set_invitation_code(const char* value) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(value);
}
inline void SelfModeActiveAccountReq::set_invitation_code(const char* value, size_t size) {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  invitation_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelfModeActiveAccountReq::mutable_invitation_code() {
  set_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    invitation_code_ = new ::std::string;
  }
  return invitation_code_;
}
inline ::std::string* SelfModeActiveAccountReq::release_invitation_code() {
  clear_has_invitation_code();
  if (invitation_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invitation_code_;
    invitation_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelfModeActiveAccountReq::set_allocated_invitation_code(::std::string* invitation_code) {
  if (invitation_code_ != &::google::protobuf::internal::kEmptyString) {
    delete invitation_code_;
  }
  if (invitation_code) {
    set_has_invitation_code();
    invitation_code_ = invitation_code;
  } else {
    clear_has_invitation_code();
    invitation_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SelfModeActiveAccountAck

// optional int32 err_no = 1;
inline bool SelfModeActiveAccountAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelfModeActiveAccountAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelfModeActiveAccountAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelfModeActiveAccountAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 SelfModeActiveAccountAck::err_no() const {
  return err_no_;
}
inline void SelfModeActiveAccountAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace loginclient
}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_loginclient_2eproto__INCLUDED
