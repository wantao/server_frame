// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trs_client.proto

#ifndef PROTOBUF_trs_5fclient_2eproto__INCLUDED
#define PROTOBUF_trs_5fclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protoc {
namespace trs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trs_5fclient_2eproto();
void protobuf_AssignDesc_trs_5fclient_2eproto();
void protobuf_ShutdownFile_trs_5fclient_2eproto();

class CRandCheckReq;
class CRandCheckAck;
class PostTrasnFileReq;
class PostTrasnFileAck;
class TrasnFileRpt;
class TransFileCompleteRpt;
class PostTransLogFileReq;
class PostTransLogFileAck;
class ReplyCanTransLogFile;
class TransLogFileRpt;
class TransLogCompleteRpt;
class CheckServerStateReq;
class ServerState;
class CheckServerStateAck;
class OpenServersReq;
class ExecuteSql;
class OtherServerReportRpt;
class CheckPasswordRpt;
class ServerErrorMsgRpt;

enum ProtocID {
  id_CRandCheckReq = 1,
  id_CRandCheckAck = 2,
  id_PostTrasnFileReq = 3,
  id_PostTrasnFileAck = 4,
  id_TrasnFileRpt = 5,
  id_TransFileCompleteRpt = 6,
  id_CheckServerStateReq = 7,
  id_CheckServerStateAck = 8,
  id_OpenServersReq = 9,
  id_CheckPasswordRpt = 10,
  id_ServerErrorMsgRpt = 11,
  id_PostTransLogFileReq = 12,
  id_PostTransLogFileAck = 13,
  id_ReplyCanTransLogFile = 14,
  id_TransLogFileRpt = 15,
  id_TransLogCompleteRpt = 16,
  id_ExecuteSqlNtf = 17,
  id_OtherServerReportRpt = 100,
  one_packg_max_size = 60000
};
bool ProtocID_IsValid(int value);
const ProtocID ProtocID_MIN = id_CRandCheckReq;
const ProtocID ProtocID_MAX = one_packg_max_size;
const int ProtocID_ARRAYSIZE = ProtocID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocID_descriptor();
inline const ::std::string& ProtocID_Name(ProtocID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocID_descriptor(), value);
}
inline bool ProtocID_Parse(
    const ::std::string& name, ProtocID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocID>(
    ProtocID_descriptor(), name, value);
}
// ===================================================================

class CRandCheckReq : public ::google::protobuf::Message {
 public:
  CRandCheckReq();
  virtual ~CRandCheckReq();

  CRandCheckReq(const CRandCheckReq& from);

  inline CRandCheckReq& operator=(const CRandCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckReq& default_instance();

  void Swap(CRandCheckReq* other);

  // implements Message ----------------------------------------------

  CRandCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckReq& from);
  void MergeFrom(const CRandCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes randkeys = 1;
  inline bool has_randkeys() const;
  inline void clear_randkeys();
  static const int kRandkeysFieldNumber = 1;
  inline const ::std::string& randkeys() const;
  inline void set_randkeys(const ::std::string& value);
  inline void set_randkeys(const char* value);
  inline void set_randkeys(const void* value, size_t size);
  inline ::std::string* mutable_randkeys();
  inline ::std::string* release_randkeys();
  inline void set_allocated_randkeys(::std::string* randkeys);

  // @@protoc_insertion_point(class_scope:protoc.trs.CRandCheckReq)
 private:
  inline void set_has_randkeys();
  inline void clear_has_randkeys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randkeys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckAck : public ::google::protobuf::Message {
 public:
  CRandCheckAck();
  virtual ~CRandCheckAck();

  CRandCheckAck(const CRandCheckAck& from);

  inline CRandCheckAck& operator=(const CRandCheckAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckAck& default_instance();

  void Swap(CRandCheckAck* other);

  // implements Message ----------------------------------------------

  CRandCheckAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckAck& from);
  void MergeFrom(const CRandCheckAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes keys = 1;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys() const;
  inline void set_keys(const ::std::string& value);
  inline void set_keys(const char* value);
  inline void set_keys(const void* value, size_t size);
  inline ::std::string* mutable_keys();
  inline ::std::string* release_keys();
  inline void set_allocated_keys(::std::string* keys);

  // @@protoc_insertion_point(class_scope:protoc.trs.CRandCheckAck)
 private:
  inline void set_has_keys();
  inline void clear_has_keys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckAck* default_instance_;
};
// -------------------------------------------------------------------

class PostTrasnFileReq : public ::google::protobuf::Message {
 public:
  PostTrasnFileReq();
  virtual ~PostTrasnFileReq();

  PostTrasnFileReq(const PostTrasnFileReq& from);

  inline PostTrasnFileReq& operator=(const PostTrasnFileReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTrasnFileReq& default_instance();

  void Swap(PostTrasnFileReq* other);

  // implements Message ----------------------------------------------

  PostTrasnFileReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTrasnFileReq& from);
  void MergeFrom(const PostTrasnFileReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 file_length_zip = 1;
  inline bool has_file_length_zip() const;
  inline void clear_file_length_zip();
  static const int kFileLengthZipFieldNumber = 1;
  inline ::google::protobuf::uint32 file_length_zip() const;
  inline void set_file_length_zip(::google::protobuf::uint32 value);

  // optional uint32 file_length_uzip = 2;
  inline bool has_file_length_uzip() const;
  inline void clear_file_length_uzip();
  static const int kFileLengthUzipFieldNumber = 2;
  inline ::google::protobuf::uint32 file_length_uzip() const;
  inline void set_file_length_uzip(::google::protobuf::uint32 value);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string file_md5 = 4;
  inline bool has_file_md5() const;
  inline void clear_file_md5();
  static const int kFileMd5FieldNumber = 4;
  inline const ::std::string& file_md5() const;
  inline void set_file_md5(const ::std::string& value);
  inline void set_file_md5(const char* value);
  inline void set_file_md5(const char* value, size_t size);
  inline ::std::string* mutable_file_md5();
  inline ::std::string* release_file_md5();
  inline void set_allocated_file_md5(::std::string* file_md5);

  // optional string server_name = 5;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 5;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // @@protoc_insertion_point(class_scope:protoc.trs.PostTrasnFileReq)
 private:
  inline void set_has_file_length_zip();
  inline void clear_has_file_length_zip();
  inline void set_has_file_length_uzip();
  inline void clear_has_file_length_uzip();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_md5();
  inline void clear_has_file_md5();
  inline void set_has_server_name();
  inline void clear_has_server_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 file_length_zip_;
  ::google::protobuf::uint32 file_length_uzip_;
  ::std::string* file_name_;
  ::std::string* file_md5_;
  ::std::string* server_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static PostTrasnFileReq* default_instance_;
};
// -------------------------------------------------------------------

class PostTrasnFileAck : public ::google::protobuf::Message {
 public:
  PostTrasnFileAck();
  virtual ~PostTrasnFileAck();

  PostTrasnFileAck(const PostTrasnFileAck& from);

  inline PostTrasnFileAck& operator=(const PostTrasnFileAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTrasnFileAck& default_instance();

  void Swap(PostTrasnFileAck* other);

  // implements Message ----------------------------------------------

  PostTrasnFileAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTrasnFileAck& from);
  void MergeFrom(const PostTrasnFileAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 2;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.PostTrasnFileAck)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* err_msg_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static PostTrasnFileAck* default_instance_;
};
// -------------------------------------------------------------------

class TrasnFileRpt : public ::google::protobuf::Message {
 public:
  TrasnFileRpt();
  virtual ~TrasnFileRpt();

  TrasnFileRpt(const TrasnFileRpt& from);

  inline TrasnFileRpt& operator=(const TrasnFileRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrasnFileRpt& default_instance();

  void Swap(TrasnFileRpt* other);

  // implements Message ----------------------------------------------

  TrasnFileRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrasnFileRpt& from);
  void MergeFrom(const TrasnFileRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes file_data = 1;
  inline bool has_file_data() const;
  inline void clear_file_data();
  static const int kFileDataFieldNumber = 1;
  inline const ::std::string& file_data() const;
  inline void set_file_data(const ::std::string& value);
  inline void set_file_data(const char* value);
  inline void set_file_data(const void* value, size_t size);
  inline ::std::string* mutable_file_data();
  inline ::std::string* release_file_data();
  inline void set_allocated_file_data(::std::string* file_data);

  // optional bool blast = 2;
  inline bool has_blast() const;
  inline void clear_blast();
  static const int kBlastFieldNumber = 2;
  inline bool blast() const;
  inline void set_blast(bool value);

  // @@protoc_insertion_point(class_scope:protoc.trs.TrasnFileRpt)
 private:
  inline void set_has_file_data();
  inline void clear_has_file_data();
  inline void set_has_blast();
  inline void clear_has_blast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_data_;
  bool blast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TrasnFileRpt* default_instance_;
};
// -------------------------------------------------------------------

class TransFileCompleteRpt : public ::google::protobuf::Message {
 public:
  TransFileCompleteRpt();
  virtual ~TransFileCompleteRpt();

  TransFileCompleteRpt(const TransFileCompleteRpt& from);

  inline TransFileCompleteRpt& operator=(const TransFileCompleteRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransFileCompleteRpt& default_instance();

  void Swap(TransFileCompleteRpt* other);

  // implements Message ----------------------------------------------

  TransFileCompleteRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransFileCompleteRpt& from);
  void MergeFrom(const TransFileCompleteRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional int32 err_no = 2;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 2;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 3;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 3;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.TransFileCompleteRpt)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 err_no_;
  ::std::string* err_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TransFileCompleteRpt* default_instance_;
};
// -------------------------------------------------------------------

class PostTransLogFileReq : public ::google::protobuf::Message {
 public:
  PostTransLogFileReq();
  virtual ~PostTransLogFileReq();

  PostTransLogFileReq(const PostTransLogFileReq& from);

  inline PostTransLogFileReq& operator=(const PostTransLogFileReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTransLogFileReq& default_instance();

  void Swap(PostTransLogFileReq* other);

  // implements Message ----------------------------------------------

  PostTransLogFileReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTransLogFileReq& from);
  void MergeFrom(const PostTransLogFileReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_name = 1;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 1;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional string logtype = 2;
  inline bool has_logtype() const;
  inline void clear_logtype();
  static const int kLogtypeFieldNumber = 2;
  inline const ::std::string& logtype() const;
  inline void set_logtype(const ::std::string& value);
  inline void set_logtype(const char* value);
  inline void set_logtype(const char* value, size_t size);
  inline ::std::string* mutable_logtype();
  inline ::std::string* release_logtype();
  inline void set_allocated_logtype(::std::string* logtype);

  // optional int32 day_idx = 3;
  inline bool has_day_idx() const;
  inline void clear_day_idx();
  static const int kDayIdxFieldNumber = 3;
  inline ::google::protobuf::int32 day_idx() const;
  inline void set_day_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.trs.PostTransLogFileReq)
 private:
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_logtype();
  inline void clear_has_logtype();
  inline void set_has_day_idx();
  inline void clear_has_day_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_name_;
  ::std::string* logtype_;
  ::google::protobuf::int32 day_idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static PostTransLogFileReq* default_instance_;
};
// -------------------------------------------------------------------

class PostTransLogFileAck : public ::google::protobuf::Message {
 public:
  PostTransLogFileAck();
  virtual ~PostTransLogFileAck();

  PostTransLogFileAck(const PostTransLogFileAck& from);

  inline PostTransLogFileAck& operator=(const PostTransLogFileAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTransLogFileAck& default_instance();

  void Swap(PostTransLogFileAck* other);

  // implements Message ----------------------------------------------

  PostTransLogFileAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTransLogFileAck& from);
  void MergeFrom(const PostTransLogFileAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 file_length_zip = 1;
  inline bool has_file_length_zip() const;
  inline void clear_file_length_zip();
  static const int kFileLengthZipFieldNumber = 1;
  inline ::google::protobuf::uint32 file_length_zip() const;
  inline void set_file_length_zip(::google::protobuf::uint32 value);

  // optional uint32 file_length_uzip = 2;
  inline bool has_file_length_uzip() const;
  inline void clear_file_length_uzip();
  static const int kFileLengthUzipFieldNumber = 2;
  inline ::google::protobuf::uint32 file_length_uzip() const;
  inline void set_file_length_uzip(::google::protobuf::uint32 value);

  // optional string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string file_md5 = 4;
  inline bool has_file_md5() const;
  inline void clear_file_md5();
  static const int kFileMd5FieldNumber = 4;
  inline const ::std::string& file_md5() const;
  inline void set_file_md5(const ::std::string& value);
  inline void set_file_md5(const char* value);
  inline void set_file_md5(const char* value, size_t size);
  inline ::std::string* mutable_file_md5();
  inline ::std::string* release_file_md5();
  inline void set_allocated_file_md5(::std::string* file_md5);

  // optional string server_name = 5;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 5;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional int32 err_no = 6;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 6;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 7;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 7;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.PostTransLogFileAck)
 private:
  inline void set_has_file_length_zip();
  inline void clear_has_file_length_zip();
  inline void set_has_file_length_uzip();
  inline void clear_has_file_length_uzip();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_md5();
  inline void clear_has_file_md5();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 file_length_zip_;
  ::google::protobuf::uint32 file_length_uzip_;
  ::std::string* file_name_;
  ::std::string* file_md5_;
  ::std::string* server_name_;
  ::std::string* err_msg_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static PostTransLogFileAck* default_instance_;
};
// -------------------------------------------------------------------

class ReplyCanTransLogFile : public ::google::protobuf::Message {
 public:
  ReplyCanTransLogFile();
  virtual ~ReplyCanTransLogFile();

  ReplyCanTransLogFile(const ReplyCanTransLogFile& from);

  inline ReplyCanTransLogFile& operator=(const ReplyCanTransLogFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyCanTransLogFile& default_instance();

  void Swap(ReplyCanTransLogFile* other);

  // implements Message ----------------------------------------------

  ReplyCanTransLogFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyCanTransLogFile& from);
  void MergeFrom(const ReplyCanTransLogFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 2;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.ReplyCanTransLogFile)
 private:
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* err_msg_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static ReplyCanTransLogFile* default_instance_;
};
// -------------------------------------------------------------------

class TransLogFileRpt : public ::google::protobuf::Message {
 public:
  TransLogFileRpt();
  virtual ~TransLogFileRpt();

  TransLogFileRpt(const TransLogFileRpt& from);

  inline TransLogFileRpt& operator=(const TransLogFileRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransLogFileRpt& default_instance();

  void Swap(TransLogFileRpt* other);

  // implements Message ----------------------------------------------

  TransLogFileRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransLogFileRpt& from);
  void MergeFrom(const TransLogFileRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes file_data = 1;
  inline bool has_file_data() const;
  inline void clear_file_data();
  static const int kFileDataFieldNumber = 1;
  inline const ::std::string& file_data() const;
  inline void set_file_data(const ::std::string& value);
  inline void set_file_data(const char* value);
  inline void set_file_data(const void* value, size_t size);
  inline ::std::string* mutable_file_data();
  inline ::std::string* release_file_data();
  inline void set_allocated_file_data(::std::string* file_data);

  // optional int32 percent = 2;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 2;
  inline ::google::protobuf::int32 percent() const;
  inline void set_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.trs.TransLogFileRpt)
 private:
  inline void set_has_file_data();
  inline void clear_has_file_data();
  inline void set_has_percent();
  inline void clear_has_percent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_data_;
  ::google::protobuf::int32 percent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TransLogFileRpt* default_instance_;
};
// -------------------------------------------------------------------

class TransLogCompleteRpt : public ::google::protobuf::Message {
 public:
  TransLogCompleteRpt();
  virtual ~TransLogCompleteRpt();

  TransLogCompleteRpt(const TransLogCompleteRpt& from);

  inline TransLogCompleteRpt& operator=(const TransLogCompleteRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransLogCompleteRpt& default_instance();

  void Swap(TransLogCompleteRpt* other);

  // implements Message ----------------------------------------------

  TransLogCompleteRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransLogCompleteRpt& from);
  void MergeFrom(const TransLogCompleteRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional int32 err_no = 2;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 2;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 3;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 3;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.TransLogCompleteRpt)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 err_no_;
  ::std::string* err_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static TransLogCompleteRpt* default_instance_;
};
// -------------------------------------------------------------------

class CheckServerStateReq : public ::google::protobuf::Message {
 public:
  CheckServerStateReq();
  virtual ~CheckServerStateReq();

  CheckServerStateReq(const CheckServerStateReq& from);

  inline CheckServerStateReq& operator=(const CheckServerStateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckServerStateReq& default_instance();

  void Swap(CheckServerStateReq* other);

  // implements Message ----------------------------------------------

  CheckServerStateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckServerStateReq& from);
  void MergeFrom(const CheckServerStateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server = 1;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 1;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  inline void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:protoc.trs.CheckServerStateReq)
 private:
  inline void set_has_server();
  inline void clear_has_server();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CheckServerStateReq* default_instance_;
};
// -------------------------------------------------------------------

class ServerState : public ::google::protobuf::Message {
 public:
  ServerState();
  virtual ~ServerState();

  ServerState(const ServerState& from);

  inline ServerState& operator=(const ServerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerState& default_instance();

  void Swap(ServerState* other);

  // implements Message ----------------------------------------------

  ServerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerState& from);
  void MergeFrom(const ServerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string area_no = 1;
  inline bool has_area_no() const;
  inline void clear_area_no();
  static const int kAreaNoFieldNumber = 1;
  inline const ::std::string& area_no() const;
  inline void set_area_no(const ::std::string& value);
  inline void set_area_no(const char* value);
  inline void set_area_no(const char* value, size_t size);
  inline ::std::string* mutable_area_no();
  inline ::std::string* release_area_no();
  inline void set_allocated_area_no(::std::string* area_no);

  // optional string area_name = 2;
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 2;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  inline void set_allocated_area_name(::std::string* area_name);

  // repeated string server_name = 3;
  inline int server_name_size() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 3;
  inline const ::std::string& server_name(int index) const;
  inline ::std::string* mutable_server_name(int index);
  inline void set_server_name(int index, const ::std::string& value);
  inline void set_server_name(int index, const char* value);
  inline void set_server_name(int index, const char* value, size_t size);
  inline ::std::string* add_server_name();
  inline void add_server_name(const ::std::string& value);
  inline void add_server_name(const char* value);
  inline void add_server_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& server_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_server_name();

  // optional string server = 4;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 4;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  inline void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:protoc.trs.ServerState)
 private:
  inline void set_has_area_no();
  inline void clear_has_area_no();
  inline void set_has_area_name();
  inline void clear_has_area_name();
  inline void set_has_server();
  inline void clear_has_server();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* area_no_;
  ::std::string* area_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> server_name_;
  ::std::string* server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static ServerState* default_instance_;
};
// -------------------------------------------------------------------

class CheckServerStateAck : public ::google::protobuf::Message {
 public:
  CheckServerStateAck();
  virtual ~CheckServerStateAck();

  CheckServerStateAck(const CheckServerStateAck& from);

  inline CheckServerStateAck& operator=(const CheckServerStateAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckServerStateAck& default_instance();

  void Swap(CheckServerStateAck* other);

  // implements Message ----------------------------------------------

  CheckServerStateAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckServerStateAck& from);
  void MergeFrom(const CheckServerStateAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protoc.trs.ServerState ss = 1;
  inline int ss_size() const;
  inline void clear_ss();
  static const int kSsFieldNumber = 1;
  inline const ::protoc::trs::ServerState& ss(int index) const;
  inline ::protoc::trs::ServerState* mutable_ss(int index);
  inline ::protoc::trs::ServerState* add_ss();
  inline const ::google::protobuf::RepeatedPtrField< ::protoc::trs::ServerState >&
      ss() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoc::trs::ServerState >*
      mutable_ss();

  // @@protoc_insertion_point(class_scope:protoc.trs.CheckServerStateAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protoc::trs::ServerState > ss_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CheckServerStateAck* default_instance_;
};
// -------------------------------------------------------------------

class OpenServersReq : public ::google::protobuf::Message {
 public:
  OpenServersReq();
  virtual ~OpenServersReq();

  OpenServersReq(const OpenServersReq& from);

  inline OpenServersReq& operator=(const OpenServersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenServersReq& default_instance();

  void Swap(OpenServersReq* other);

  // implements Message ----------------------------------------------

  OpenServersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenServersReq& from);
  void MergeFrom(const OpenServersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.trs.OpenServersReq)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static OpenServersReq* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteSql : public ::google::protobuf::Message {
 public:
  ExecuteSql();
  virtual ~ExecuteSql();

  ExecuteSql(const ExecuteSql& from);

  inline ExecuteSql& operator=(const ExecuteSql& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteSql& default_instance();

  void Swap(ExecuteSql* other);

  // implements Message ----------------------------------------------

  ExecuteSql* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteSql& from);
  void MergeFrom(const ExecuteSql& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str_info = 1;
  inline bool has_str_info() const;
  inline void clear_str_info();
  static const int kStrInfoFieldNumber = 1;
  inline const ::std::string& str_info() const;
  inline void set_str_info(const ::std::string& value);
  inline void set_str_info(const char* value);
  inline void set_str_info(const char* value, size_t size);
  inline ::std::string* mutable_str_info();
  inline ::std::string* release_str_info();
  inline void set_allocated_str_info(::std::string* str_info);

  // @@protoc_insertion_point(class_scope:protoc.trs.ExecuteSql)
 private:
  inline void set_has_str_info();
  inline void clear_has_str_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static ExecuteSql* default_instance_;
};
// -------------------------------------------------------------------

class OtherServerReportRpt : public ::google::protobuf::Message {
 public:
  OtherServerReportRpt();
  virtual ~OtherServerReportRpt();

  OtherServerReportRpt(const OtherServerReportRpt& from);

  inline OtherServerReportRpt& operator=(const OtherServerReportRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherServerReportRpt& default_instance();

  void Swap(OtherServerReportRpt* other);

  // implements Message ----------------------------------------------

  OtherServerReportRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtherServerReportRpt& from);
  void MergeFrom(const OtherServerReportRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_name = 1;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 1;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional string server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline const ::std::string& server_id() const;
  inline void set_server_id(const ::std::string& value);
  inline void set_server_id(const char* value);
  inline void set_server_id(const char* value, size_t size);
  inline ::std::string* mutable_server_id();
  inline ::std::string* release_server_id();
  inline void set_allocated_server_id(::std::string* server_id);

  // @@protoc_insertion_point(class_scope:protoc.trs.OtherServerReportRpt)
 private:
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_server_id();
  inline void clear_has_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_name_;
  ::std::string* server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static OtherServerReportRpt* default_instance_;
};
// -------------------------------------------------------------------

class CheckPasswordRpt : public ::google::protobuf::Message {
 public:
  CheckPasswordRpt();
  virtual ~CheckPasswordRpt();

  CheckPasswordRpt(const CheckPasswordRpt& from);

  inline CheckPasswordRpt& operator=(const CheckPasswordRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckPasswordRpt& default_instance();

  void Swap(CheckPasswordRpt* other);

  // implements Message ----------------------------------------------

  CheckPasswordRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckPasswordRpt& from);
  void MergeFrom(const CheckPasswordRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string psw = 1;
  inline bool has_psw() const;
  inline void clear_psw();
  static const int kPswFieldNumber = 1;
  inline const ::std::string& psw() const;
  inline void set_psw(const ::std::string& value);
  inline void set_psw(const char* value);
  inline void set_psw(const char* value, size_t size);
  inline ::std::string* mutable_psw();
  inline ::std::string* release_psw();
  inline void set_allocated_psw(::std::string* psw);

  // @@protoc_insertion_point(class_scope:protoc.trs.CheckPasswordRpt)
 private:
  inline void set_has_psw();
  inline void clear_has_psw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* psw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static CheckPasswordRpt* default_instance_;
};
// -------------------------------------------------------------------

class ServerErrorMsgRpt : public ::google::protobuf::Message {
 public:
  ServerErrorMsgRpt();
  virtual ~ServerErrorMsgRpt();

  ServerErrorMsgRpt(const ServerErrorMsgRpt& from);

  inline ServerErrorMsgRpt& operator=(const ServerErrorMsgRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerErrorMsgRpt& default_instance();

  void Swap(ServerErrorMsgRpt* other);

  // implements Message ----------------------------------------------

  ServerErrorMsgRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerErrorMsgRpt& from);
  void MergeFrom(const ServerErrorMsgRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string err_msg = 1;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 1;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // @@protoc_insertion_point(class_scope:protoc.trs.ServerErrorMsgRpt)
 private:
  inline void set_has_err_msg();
  inline void clear_has_err_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* err_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trs_5fclient_2eproto();
  friend void protobuf_AssignDesc_trs_5fclient_2eproto();
  friend void protobuf_ShutdownFile_trs_5fclient_2eproto();

  void InitAsDefaultInstance();
  static ServerErrorMsgRpt* default_instance_;
};
// ===================================================================


// ===================================================================

// CRandCheckReq

// optional bytes randkeys = 1;
inline bool CRandCheckReq::has_randkeys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckReq::set_has_randkeys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckReq::clear_has_randkeys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckReq::clear_randkeys() {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    randkeys_->clear();
  }
  clear_has_randkeys();
}
inline const ::std::string& CRandCheckReq::randkeys() const {
  return *randkeys_;
}
inline void CRandCheckReq::set_randkeys(const ::std::string& value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const char* value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const void* value, size_t size) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckReq::mutable_randkeys() {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  return randkeys_;
}
inline ::std::string* CRandCheckReq::release_randkeys() {
  clear_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randkeys_;
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckReq::set_allocated_randkeys(::std::string* randkeys) {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    delete randkeys_;
  }
  if (randkeys) {
    set_has_randkeys();
    randkeys_ = randkeys;
  } else {
    clear_has_randkeys();
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRandCheckAck

// optional bytes keys = 1;
inline bool CRandCheckAck::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckAck::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckAck::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckAck::clear_keys() {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    keys_->clear();
  }
  clear_has_keys();
}
inline const ::std::string& CRandCheckAck::keys() const {
  return *keys_;
}
inline void CRandCheckAck::set_keys(const ::std::string& value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const char* value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const void* value, size_t size) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckAck::mutable_keys() {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  return keys_;
}
inline ::std::string* CRandCheckAck::release_keys() {
  clear_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keys_;
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckAck::set_allocated_keys(::std::string* keys) {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    delete keys_;
  }
  if (keys) {
    set_has_keys();
    keys_ = keys;
  } else {
    clear_has_keys();
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostTrasnFileReq

// optional uint32 file_length_zip = 1;
inline bool PostTrasnFileReq::has_file_length_zip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTrasnFileReq::set_has_file_length_zip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTrasnFileReq::clear_has_file_length_zip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTrasnFileReq::clear_file_length_zip() {
  file_length_zip_ = 0u;
  clear_has_file_length_zip();
}
inline ::google::protobuf::uint32 PostTrasnFileReq::file_length_zip() const {
  return file_length_zip_;
}
inline void PostTrasnFileReq::set_file_length_zip(::google::protobuf::uint32 value) {
  set_has_file_length_zip();
  file_length_zip_ = value;
}

// optional uint32 file_length_uzip = 2;
inline bool PostTrasnFileReq::has_file_length_uzip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTrasnFileReq::set_has_file_length_uzip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTrasnFileReq::clear_has_file_length_uzip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTrasnFileReq::clear_file_length_uzip() {
  file_length_uzip_ = 0u;
  clear_has_file_length_uzip();
}
inline ::google::protobuf::uint32 PostTrasnFileReq::file_length_uzip() const {
  return file_length_uzip_;
}
inline void PostTrasnFileReq::set_file_length_uzip(::google::protobuf::uint32 value) {
  set_has_file_length_uzip();
  file_length_uzip_ = value;
}

// optional string file_name = 3;
inline bool PostTrasnFileReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostTrasnFileReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostTrasnFileReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostTrasnFileReq::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& PostTrasnFileReq::file_name() const {
  return *file_name_;
}
inline void PostTrasnFileReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void PostTrasnFileReq::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void PostTrasnFileReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTrasnFileReq::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* PostTrasnFileReq::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTrasnFileReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_md5 = 4;
inline bool PostTrasnFileReq::has_file_md5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PostTrasnFileReq::set_has_file_md5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PostTrasnFileReq::clear_has_file_md5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PostTrasnFileReq::clear_file_md5() {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    file_md5_->clear();
  }
  clear_has_file_md5();
}
inline const ::std::string& PostTrasnFileReq::file_md5() const {
  return *file_md5_;
}
inline void PostTrasnFileReq::set_file_md5(const ::std::string& value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void PostTrasnFileReq::set_file_md5(const char* value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void PostTrasnFileReq::set_file_md5(const char* value, size_t size) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTrasnFileReq::mutable_file_md5() {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  return file_md5_;
}
inline ::std::string* PostTrasnFileReq::release_file_md5() {
  clear_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_md5_;
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTrasnFileReq::set_allocated_file_md5(::std::string* file_md5) {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete file_md5_;
  }
  if (file_md5) {
    set_has_file_md5();
    file_md5_ = file_md5;
  } else {
    clear_has_file_md5();
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_name = 5;
inline bool PostTrasnFileReq::has_server_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PostTrasnFileReq::set_has_server_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PostTrasnFileReq::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PostTrasnFileReq::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& PostTrasnFileReq::server_name() const {
  return *server_name_;
}
inline void PostTrasnFileReq::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTrasnFileReq::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTrasnFileReq::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTrasnFileReq::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* PostTrasnFileReq::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTrasnFileReq::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostTrasnFileAck

// optional int32 err_no = 1;
inline bool PostTrasnFileAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTrasnFileAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTrasnFileAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTrasnFileAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 PostTrasnFileAck::err_no() const {
  return err_no_;
}
inline void PostTrasnFileAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 2;
inline bool PostTrasnFileAck::has_err_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTrasnFileAck::set_has_err_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTrasnFileAck::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTrasnFileAck::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& PostTrasnFileAck::err_msg() const {
  return *err_msg_;
}
inline void PostTrasnFileAck::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void PostTrasnFileAck::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void PostTrasnFileAck::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTrasnFileAck::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* PostTrasnFileAck::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTrasnFileAck::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TrasnFileRpt

// optional bytes file_data = 1;
inline bool TrasnFileRpt::has_file_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrasnFileRpt::set_has_file_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrasnFileRpt::clear_has_file_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrasnFileRpt::clear_file_data() {
  if (file_data_ != &::google::protobuf::internal::kEmptyString) {
    file_data_->clear();
  }
  clear_has_file_data();
}
inline const ::std::string& TrasnFileRpt::file_data() const {
  return *file_data_;
}
inline void TrasnFileRpt::set_file_data(const ::std::string& value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void TrasnFileRpt::set_file_data(const char* value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void TrasnFileRpt::set_file_data(const void* value, size_t size) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrasnFileRpt::mutable_file_data() {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  return file_data_;
}
inline ::std::string* TrasnFileRpt::release_file_data() {
  clear_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_data_;
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrasnFileRpt::set_allocated_file_data(::std::string* file_data) {
  if (file_data_ != &::google::protobuf::internal::kEmptyString) {
    delete file_data_;
  }
  if (file_data) {
    set_has_file_data();
    file_data_ = file_data;
  } else {
    clear_has_file_data();
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool blast = 2;
inline bool TrasnFileRpt::has_blast() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrasnFileRpt::set_has_blast() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrasnFileRpt::clear_has_blast() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrasnFileRpt::clear_blast() {
  blast_ = false;
  clear_has_blast();
}
inline bool TrasnFileRpt::blast() const {
  return blast_;
}
inline void TrasnFileRpt::set_blast(bool value) {
  set_has_blast();
  blast_ = value;
}

// -------------------------------------------------------------------

// TransFileCompleteRpt

// optional int32 length = 1;
inline bool TransFileCompleteRpt::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransFileCompleteRpt::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransFileCompleteRpt::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransFileCompleteRpt::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 TransFileCompleteRpt::length() const {
  return length_;
}
inline void TransFileCompleteRpt::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional int32 err_no = 2;
inline bool TransFileCompleteRpt::has_err_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransFileCompleteRpt::set_has_err_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransFileCompleteRpt::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransFileCompleteRpt::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 TransFileCompleteRpt::err_no() const {
  return err_no_;
}
inline void TransFileCompleteRpt::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 3;
inline bool TransFileCompleteRpt::has_err_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransFileCompleteRpt::set_has_err_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransFileCompleteRpt::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransFileCompleteRpt::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& TransFileCompleteRpt::err_msg() const {
  return *err_msg_;
}
inline void TransFileCompleteRpt::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void TransFileCompleteRpt::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void TransFileCompleteRpt::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransFileCompleteRpt::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* TransFileCompleteRpt::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransFileCompleteRpt::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostTransLogFileReq

// optional string server_name = 1;
inline bool PostTransLogFileReq::has_server_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTransLogFileReq::set_has_server_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTransLogFileReq::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTransLogFileReq::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& PostTransLogFileReq::server_name() const {
  return *server_name_;
}
inline void PostTransLogFileReq::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTransLogFileReq::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTransLogFileReq::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileReq::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* PostTransLogFileReq::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileReq::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string logtype = 2;
inline bool PostTransLogFileReq::has_logtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTransLogFileReq::set_has_logtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTransLogFileReq::clear_has_logtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTransLogFileReq::clear_logtype() {
  if (logtype_ != &::google::protobuf::internal::kEmptyString) {
    logtype_->clear();
  }
  clear_has_logtype();
}
inline const ::std::string& PostTransLogFileReq::logtype() const {
  return *logtype_;
}
inline void PostTransLogFileReq::set_logtype(const ::std::string& value) {
  set_has_logtype();
  if (logtype_ == &::google::protobuf::internal::kEmptyString) {
    logtype_ = new ::std::string;
  }
  logtype_->assign(value);
}
inline void PostTransLogFileReq::set_logtype(const char* value) {
  set_has_logtype();
  if (logtype_ == &::google::protobuf::internal::kEmptyString) {
    logtype_ = new ::std::string;
  }
  logtype_->assign(value);
}
inline void PostTransLogFileReq::set_logtype(const char* value, size_t size) {
  set_has_logtype();
  if (logtype_ == &::google::protobuf::internal::kEmptyString) {
    logtype_ = new ::std::string;
  }
  logtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileReq::mutable_logtype() {
  set_has_logtype();
  if (logtype_ == &::google::protobuf::internal::kEmptyString) {
    logtype_ = new ::std::string;
  }
  return logtype_;
}
inline ::std::string* PostTransLogFileReq::release_logtype() {
  clear_has_logtype();
  if (logtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logtype_;
    logtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileReq::set_allocated_logtype(::std::string* logtype) {
  if (logtype_ != &::google::protobuf::internal::kEmptyString) {
    delete logtype_;
  }
  if (logtype) {
    set_has_logtype();
    logtype_ = logtype;
  } else {
    clear_has_logtype();
    logtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 day_idx = 3;
inline bool PostTransLogFileReq::has_day_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostTransLogFileReq::set_has_day_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostTransLogFileReq::clear_has_day_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostTransLogFileReq::clear_day_idx() {
  day_idx_ = 0;
  clear_has_day_idx();
}
inline ::google::protobuf::int32 PostTransLogFileReq::day_idx() const {
  return day_idx_;
}
inline void PostTransLogFileReq::set_day_idx(::google::protobuf::int32 value) {
  set_has_day_idx();
  day_idx_ = value;
}

// -------------------------------------------------------------------

// PostTransLogFileAck

// optional uint32 file_length_zip = 1;
inline bool PostTransLogFileAck::has_file_length_zip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTransLogFileAck::set_has_file_length_zip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTransLogFileAck::clear_has_file_length_zip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTransLogFileAck::clear_file_length_zip() {
  file_length_zip_ = 0u;
  clear_has_file_length_zip();
}
inline ::google::protobuf::uint32 PostTransLogFileAck::file_length_zip() const {
  return file_length_zip_;
}
inline void PostTransLogFileAck::set_file_length_zip(::google::protobuf::uint32 value) {
  set_has_file_length_zip();
  file_length_zip_ = value;
}

// optional uint32 file_length_uzip = 2;
inline bool PostTransLogFileAck::has_file_length_uzip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTransLogFileAck::set_has_file_length_uzip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTransLogFileAck::clear_has_file_length_uzip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTransLogFileAck::clear_file_length_uzip() {
  file_length_uzip_ = 0u;
  clear_has_file_length_uzip();
}
inline ::google::protobuf::uint32 PostTransLogFileAck::file_length_uzip() const {
  return file_length_uzip_;
}
inline void PostTransLogFileAck::set_file_length_uzip(::google::protobuf::uint32 value) {
  set_has_file_length_uzip();
  file_length_uzip_ = value;
}

// optional string file_name = 3;
inline bool PostTransLogFileAck::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostTransLogFileAck::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostTransLogFileAck::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostTransLogFileAck::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& PostTransLogFileAck::file_name() const {
  return *file_name_;
}
inline void PostTransLogFileAck::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void PostTransLogFileAck::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void PostTransLogFileAck::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileAck::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* PostTransLogFileAck::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileAck::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string file_md5 = 4;
inline bool PostTransLogFileAck::has_file_md5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PostTransLogFileAck::set_has_file_md5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PostTransLogFileAck::clear_has_file_md5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PostTransLogFileAck::clear_file_md5() {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    file_md5_->clear();
  }
  clear_has_file_md5();
}
inline const ::std::string& PostTransLogFileAck::file_md5() const {
  return *file_md5_;
}
inline void PostTransLogFileAck::set_file_md5(const ::std::string& value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void PostTransLogFileAck::set_file_md5(const char* value) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(value);
}
inline void PostTransLogFileAck::set_file_md5(const char* value, size_t size) {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  file_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileAck::mutable_file_md5() {
  set_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    file_md5_ = new ::std::string;
  }
  return file_md5_;
}
inline ::std::string* PostTransLogFileAck::release_file_md5() {
  clear_has_file_md5();
  if (file_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_md5_;
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileAck::set_allocated_file_md5(::std::string* file_md5) {
  if (file_md5_ != &::google::protobuf::internal::kEmptyString) {
    delete file_md5_;
  }
  if (file_md5) {
    set_has_file_md5();
    file_md5_ = file_md5;
  } else {
    clear_has_file_md5();
    file_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_name = 5;
inline bool PostTransLogFileAck::has_server_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PostTransLogFileAck::set_has_server_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PostTransLogFileAck::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PostTransLogFileAck::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& PostTransLogFileAck::server_name() const {
  return *server_name_;
}
inline void PostTransLogFileAck::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTransLogFileAck::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void PostTransLogFileAck::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileAck::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* PostTransLogFileAck::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileAck::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 err_no = 6;
inline bool PostTransLogFileAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PostTransLogFileAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PostTransLogFileAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PostTransLogFileAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 PostTransLogFileAck::err_no() const {
  return err_no_;
}
inline void PostTransLogFileAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 7;
inline bool PostTransLogFileAck::has_err_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PostTransLogFileAck::set_has_err_msg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PostTransLogFileAck::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PostTransLogFileAck::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& PostTransLogFileAck::err_msg() const {
  return *err_msg_;
}
inline void PostTransLogFileAck::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void PostTransLogFileAck::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void PostTransLogFileAck::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTransLogFileAck::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* PostTransLogFileAck::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTransLogFileAck::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReplyCanTransLogFile

// optional int32 err_no = 1;
inline bool ReplyCanTransLogFile::has_err_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyCanTransLogFile::set_has_err_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyCanTransLogFile::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyCanTransLogFile::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 ReplyCanTransLogFile::err_no() const {
  return err_no_;
}
inline void ReplyCanTransLogFile::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 2;
inline bool ReplyCanTransLogFile::has_err_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyCanTransLogFile::set_has_err_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyCanTransLogFile::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyCanTransLogFile::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& ReplyCanTransLogFile::err_msg() const {
  return *err_msg_;
}
inline void ReplyCanTransLogFile::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void ReplyCanTransLogFile::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void ReplyCanTransLogFile::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyCanTransLogFile::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* ReplyCanTransLogFile::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyCanTransLogFile::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TransLogFileRpt

// optional bytes file_data = 1;
inline bool TransLogFileRpt::has_file_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransLogFileRpt::set_has_file_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransLogFileRpt::clear_has_file_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransLogFileRpt::clear_file_data() {
  if (file_data_ != &::google::protobuf::internal::kEmptyString) {
    file_data_->clear();
  }
  clear_has_file_data();
}
inline const ::std::string& TransLogFileRpt::file_data() const {
  return *file_data_;
}
inline void TransLogFileRpt::set_file_data(const ::std::string& value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void TransLogFileRpt::set_file_data(const char* value) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(value);
}
inline void TransLogFileRpt::set_file_data(const void* value, size_t size) {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  file_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransLogFileRpt::mutable_file_data() {
  set_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    file_data_ = new ::std::string;
  }
  return file_data_;
}
inline ::std::string* TransLogFileRpt::release_file_data() {
  clear_has_file_data();
  if (file_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_data_;
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransLogFileRpt::set_allocated_file_data(::std::string* file_data) {
  if (file_data_ != &::google::protobuf::internal::kEmptyString) {
    delete file_data_;
  }
  if (file_data) {
    set_has_file_data();
    file_data_ = file_data;
  } else {
    clear_has_file_data();
    file_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 percent = 2;
inline bool TransLogFileRpt::has_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransLogFileRpt::set_has_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransLogFileRpt::clear_has_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransLogFileRpt::clear_percent() {
  percent_ = 0;
  clear_has_percent();
}
inline ::google::protobuf::int32 TransLogFileRpt::percent() const {
  return percent_;
}
inline void TransLogFileRpt::set_percent(::google::protobuf::int32 value) {
  set_has_percent();
  percent_ = value;
}

// -------------------------------------------------------------------

// TransLogCompleteRpt

// optional int32 length = 1;
inline bool TransLogCompleteRpt::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransLogCompleteRpt::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransLogCompleteRpt::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransLogCompleteRpt::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 TransLogCompleteRpt::length() const {
  return length_;
}
inline void TransLogCompleteRpt::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional int32 err_no = 2;
inline bool TransLogCompleteRpt::has_err_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransLogCompleteRpt::set_has_err_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransLogCompleteRpt::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransLogCompleteRpt::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 TransLogCompleteRpt::err_no() const {
  return err_no_;
}
inline void TransLogCompleteRpt::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 3;
inline bool TransLogCompleteRpt::has_err_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransLogCompleteRpt::set_has_err_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransLogCompleteRpt::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransLogCompleteRpt::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& TransLogCompleteRpt::err_msg() const {
  return *err_msg_;
}
inline void TransLogCompleteRpt::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void TransLogCompleteRpt::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void TransLogCompleteRpt::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransLogCompleteRpt::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* TransLogCompleteRpt::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransLogCompleteRpt::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckServerStateReq

// optional string server = 1;
inline bool CheckServerStateReq::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckServerStateReq::set_has_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckServerStateReq::clear_has_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckServerStateReq::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& CheckServerStateReq::server() const {
  return *server_;
}
inline void CheckServerStateReq::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void CheckServerStateReq::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void CheckServerStateReq::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckServerStateReq::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* CheckServerStateReq::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckServerStateReq::set_allocated_server(::std::string* server) {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    delete server_;
  }
  if (server) {
    set_has_server();
    server_ = server;
  } else {
    clear_has_server();
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServerState

// optional string area_no = 1;
inline bool ServerState::has_area_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerState::set_has_area_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerState::clear_has_area_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerState::clear_area_no() {
  if (area_no_ != &::google::protobuf::internal::kEmptyString) {
    area_no_->clear();
  }
  clear_has_area_no();
}
inline const ::std::string& ServerState::area_no() const {
  return *area_no_;
}
inline void ServerState::set_area_no(const ::std::string& value) {
  set_has_area_no();
  if (area_no_ == &::google::protobuf::internal::kEmptyString) {
    area_no_ = new ::std::string;
  }
  area_no_->assign(value);
}
inline void ServerState::set_area_no(const char* value) {
  set_has_area_no();
  if (area_no_ == &::google::protobuf::internal::kEmptyString) {
    area_no_ = new ::std::string;
  }
  area_no_->assign(value);
}
inline void ServerState::set_area_no(const char* value, size_t size) {
  set_has_area_no();
  if (area_no_ == &::google::protobuf::internal::kEmptyString) {
    area_no_ = new ::std::string;
  }
  area_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerState::mutable_area_no() {
  set_has_area_no();
  if (area_no_ == &::google::protobuf::internal::kEmptyString) {
    area_no_ = new ::std::string;
  }
  return area_no_;
}
inline ::std::string* ServerState::release_area_no() {
  clear_has_area_no();
  if (area_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_no_;
    area_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerState::set_allocated_area_no(::std::string* area_no) {
  if (area_no_ != &::google::protobuf::internal::kEmptyString) {
    delete area_no_;
  }
  if (area_no) {
    set_has_area_no();
    area_no_ = area_no;
  } else {
    clear_has_area_no();
    area_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string area_name = 2;
inline bool ServerState::has_area_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerState::set_has_area_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerState::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerState::clear_area_name() {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    area_name_->clear();
  }
  clear_has_area_name();
}
inline const ::std::string& ServerState::area_name() const {
  return *area_name_;
}
inline void ServerState::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void ServerState::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void ServerState::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerState::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}
inline ::std::string* ServerState::release_area_name() {
  clear_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerState::set_allocated_area_name(::std::string* area_name) {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    delete area_name_;
  }
  if (area_name) {
    set_has_area_name();
    area_name_ = area_name;
  } else {
    clear_has_area_name();
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string server_name = 3;
inline int ServerState::server_name_size() const {
  return server_name_.size();
}
inline void ServerState::clear_server_name() {
  server_name_.Clear();
}
inline const ::std::string& ServerState::server_name(int index) const {
  return server_name_.Get(index);
}
inline ::std::string* ServerState::mutable_server_name(int index) {
  return server_name_.Mutable(index);
}
inline void ServerState::set_server_name(int index, const ::std::string& value) {
  server_name_.Mutable(index)->assign(value);
}
inline void ServerState::set_server_name(int index, const char* value) {
  server_name_.Mutable(index)->assign(value);
}
inline void ServerState::set_server_name(int index, const char* value, size_t size) {
  server_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerState::add_server_name() {
  return server_name_.Add();
}
inline void ServerState::add_server_name(const ::std::string& value) {
  server_name_.Add()->assign(value);
}
inline void ServerState::add_server_name(const char* value) {
  server_name_.Add()->assign(value);
}
inline void ServerState::add_server_name(const char* value, size_t size) {
  server_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ServerState::server_name() const {
  return server_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ServerState::mutable_server_name() {
  return &server_name_;
}

// optional string server = 4;
inline bool ServerState::has_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerState::set_has_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerState::clear_has_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerState::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& ServerState::server() const {
  return *server_;
}
inline void ServerState::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void ServerState::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void ServerState::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerState::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* ServerState::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerState::set_allocated_server(::std::string* server) {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    delete server_;
  }
  if (server) {
    set_has_server();
    server_ = server;
  } else {
    clear_has_server();
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckServerStateAck

// repeated .protoc.trs.ServerState ss = 1;
inline int CheckServerStateAck::ss_size() const {
  return ss_.size();
}
inline void CheckServerStateAck::clear_ss() {
  ss_.Clear();
}
inline const ::protoc::trs::ServerState& CheckServerStateAck::ss(int index) const {
  return ss_.Get(index);
}
inline ::protoc::trs::ServerState* CheckServerStateAck::mutable_ss(int index) {
  return ss_.Mutable(index);
}
inline ::protoc::trs::ServerState* CheckServerStateAck::add_ss() {
  return ss_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoc::trs::ServerState >&
CheckServerStateAck::ss() const {
  return ss_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoc::trs::ServerState >*
CheckServerStateAck::mutable_ss() {
  return &ss_;
}

// -------------------------------------------------------------------

// OpenServersReq

// optional int32 opt = 1;
inline bool OpenServersReq::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenServersReq::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenServersReq::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenServersReq::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 OpenServersReq::opt() const {
  return opt_;
}
inline void OpenServersReq::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// ExecuteSql

// optional string str_info = 1;
inline bool ExecuteSql::has_str_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteSql::set_has_str_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteSql::clear_has_str_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteSql::clear_str_info() {
  if (str_info_ != &::google::protobuf::internal::kEmptyString) {
    str_info_->clear();
  }
  clear_has_str_info();
}
inline const ::std::string& ExecuteSql::str_info() const {
  return *str_info_;
}
inline void ExecuteSql::set_str_info(const ::std::string& value) {
  set_has_str_info();
  if (str_info_ == &::google::protobuf::internal::kEmptyString) {
    str_info_ = new ::std::string;
  }
  str_info_->assign(value);
}
inline void ExecuteSql::set_str_info(const char* value) {
  set_has_str_info();
  if (str_info_ == &::google::protobuf::internal::kEmptyString) {
    str_info_ = new ::std::string;
  }
  str_info_->assign(value);
}
inline void ExecuteSql::set_str_info(const char* value, size_t size) {
  set_has_str_info();
  if (str_info_ == &::google::protobuf::internal::kEmptyString) {
    str_info_ = new ::std::string;
  }
  str_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecuteSql::mutable_str_info() {
  set_has_str_info();
  if (str_info_ == &::google::protobuf::internal::kEmptyString) {
    str_info_ = new ::std::string;
  }
  return str_info_;
}
inline ::std::string* ExecuteSql::release_str_info() {
  clear_has_str_info();
  if (str_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_info_;
    str_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecuteSql::set_allocated_str_info(::std::string* str_info) {
  if (str_info_ != &::google::protobuf::internal::kEmptyString) {
    delete str_info_;
  }
  if (str_info) {
    set_has_str_info();
    str_info_ = str_info;
  } else {
    clear_has_str_info();
    str_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OtherServerReportRpt

// optional string server_name = 1;
inline bool OtherServerReportRpt::has_server_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherServerReportRpt::set_has_server_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherServerReportRpt::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherServerReportRpt::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& OtherServerReportRpt::server_name() const {
  return *server_name_;
}
inline void OtherServerReportRpt::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void OtherServerReportRpt::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void OtherServerReportRpt::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OtherServerReportRpt::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* OtherServerReportRpt::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OtherServerReportRpt::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_id = 2;
inline bool OtherServerReportRpt::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherServerReportRpt::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherServerReportRpt::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherServerReportRpt::clear_server_id() {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    server_id_->clear();
  }
  clear_has_server_id();
}
inline const ::std::string& OtherServerReportRpt::server_id() const {
  return *server_id_;
}
inline void OtherServerReportRpt::set_server_id(const ::std::string& value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void OtherServerReportRpt::set_server_id(const char* value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void OtherServerReportRpt::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OtherServerReportRpt::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  return server_id_;
}
inline ::std::string* OtherServerReportRpt::release_server_id() {
  clear_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_id_;
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OtherServerReportRpt::set_allocated_server_id(::std::string* server_id) {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    delete server_id_;
  }
  if (server_id) {
    set_has_server_id();
    server_id_ = server_id;
  } else {
    clear_has_server_id();
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckPasswordRpt

// optional string psw = 1;
inline bool CheckPasswordRpt::has_psw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckPasswordRpt::set_has_psw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckPasswordRpt::clear_has_psw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckPasswordRpt::clear_psw() {
  if (psw_ != &::google::protobuf::internal::kEmptyString) {
    psw_->clear();
  }
  clear_has_psw();
}
inline const ::std::string& CheckPasswordRpt::psw() const {
  return *psw_;
}
inline void CheckPasswordRpt::set_psw(const ::std::string& value) {
  set_has_psw();
  if (psw_ == &::google::protobuf::internal::kEmptyString) {
    psw_ = new ::std::string;
  }
  psw_->assign(value);
}
inline void CheckPasswordRpt::set_psw(const char* value) {
  set_has_psw();
  if (psw_ == &::google::protobuf::internal::kEmptyString) {
    psw_ = new ::std::string;
  }
  psw_->assign(value);
}
inline void CheckPasswordRpt::set_psw(const char* value, size_t size) {
  set_has_psw();
  if (psw_ == &::google::protobuf::internal::kEmptyString) {
    psw_ = new ::std::string;
  }
  psw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckPasswordRpt::mutable_psw() {
  set_has_psw();
  if (psw_ == &::google::protobuf::internal::kEmptyString) {
    psw_ = new ::std::string;
  }
  return psw_;
}
inline ::std::string* CheckPasswordRpt::release_psw() {
  clear_has_psw();
  if (psw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psw_;
    psw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckPasswordRpt::set_allocated_psw(::std::string* psw) {
  if (psw_ != &::google::protobuf::internal::kEmptyString) {
    delete psw_;
  }
  if (psw) {
    set_has_psw();
    psw_ = psw;
  } else {
    clear_has_psw();
    psw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServerErrorMsgRpt

// optional string err_msg = 1;
inline bool ServerErrorMsgRpt::has_err_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerErrorMsgRpt::set_has_err_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerErrorMsgRpt::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerErrorMsgRpt::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& ServerErrorMsgRpt::err_msg() const {
  return *err_msg_;
}
inline void ServerErrorMsgRpt::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void ServerErrorMsgRpt::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void ServerErrorMsgRpt::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerErrorMsgRpt::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* ServerErrorMsgRpt::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerErrorMsgRpt::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace trs
}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoc::trs::ProtocID>() {
  return ::protoc::trs::ProtocID_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trs_5fclient_2eproto__INCLUDED
