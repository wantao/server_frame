// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ns.db.proto

#ifndef PROTOBUF_ns_2edb_2eproto__INCLUDED
#define PROTOBUF_ns_2edb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protoc {
namespace nsdb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ns_2edb_2eproto();
void protobuf_AssignDesc_ns_2edb_2eproto();
void protobuf_ShutdownFile_ns_2edb_2eproto();

class CDBServerInfoRpt;
class CNameServerInfoRpt;
class CRandCheckReq;
class CRandCheckAck;
class CHeartPing;
class CHeartPingAck;
class CheckNewNameReq;
class CheckNewNameAck;
class GetUniqueIDReq;
class GetUniqueIDAck;
class ChongZhiPlayer;
class ChongZhiNtf;
class report_online_number;
class GameImportLogRpt;
class GameServerMessageTransNtf;

enum E_GS_TRANS_TYPE {
  e_all = 1,
  e_except_sell = 2
};
bool E_GS_TRANS_TYPE_IsValid(int value);
const E_GS_TRANS_TYPE E_GS_TRANS_TYPE_MIN = e_all;
const E_GS_TRANS_TYPE E_GS_TRANS_TYPE_MAX = e_except_sell;
const int E_GS_TRANS_TYPE_ARRAYSIZE = E_GS_TRANS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* E_GS_TRANS_TYPE_descriptor();
inline const ::std::string& E_GS_TRANS_TYPE_Name(E_GS_TRANS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    E_GS_TRANS_TYPE_descriptor(), value);
}
inline bool E_GS_TRANS_TYPE_Parse(
    const ::std::string& name, E_GS_TRANS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_GS_TRANS_TYPE>(
    E_GS_TRANS_TYPE_descriptor(), name, value);
}
// ===================================================================

class CDBServerInfoRpt : public ::google::protobuf::Message {
 public:
  CDBServerInfoRpt();
  virtual ~CDBServerInfoRpt();

  CDBServerInfoRpt(const CDBServerInfoRpt& from);

  inline CDBServerInfoRpt& operator=(const CDBServerInfoRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDBServerInfoRpt& default_instance();

  void Swap(CDBServerInfoRpt* other);

  // implements Message ----------------------------------------------

  CDBServerInfoRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDBServerInfoRpt& from);
  void MergeFrom(const CDBServerInfoRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CDBServerInfoRpt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CDBServerInfoRpt* default_instance_;
};
// -------------------------------------------------------------------

class CNameServerInfoRpt : public ::google::protobuf::Message {
 public:
  CNameServerInfoRpt();
  virtual ~CNameServerInfoRpt();

  CNameServerInfoRpt(const CNameServerInfoRpt& from);

  inline CNameServerInfoRpt& operator=(const CNameServerInfoRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CNameServerInfoRpt& default_instance();

  void Swap(CNameServerInfoRpt* other);

  // implements Message ----------------------------------------------

  CNameServerInfoRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CNameServerInfoRpt& from);
  void MergeFrom(const CNameServerInfoRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CNameServerInfoRpt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CNameServerInfoRpt* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckReq : public ::google::protobuf::Message {
 public:
  CRandCheckReq();
  virtual ~CRandCheckReq();

  CRandCheckReq(const CRandCheckReq& from);

  inline CRandCheckReq& operator=(const CRandCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckReq& default_instance();

  void Swap(CRandCheckReq* other);

  // implements Message ----------------------------------------------

  CRandCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckReq& from);
  void MergeFrom(const CRandCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes randkeys = 1;
  inline bool has_randkeys() const;
  inline void clear_randkeys();
  static const int kRandkeysFieldNumber = 1;
  inline const ::std::string& randkeys() const;
  inline void set_randkeys(const ::std::string& value);
  inline void set_randkeys(const char* value);
  inline void set_randkeys(const void* value, size_t size);
  inline ::std::string* mutable_randkeys();
  inline ::std::string* release_randkeys();
  inline void set_allocated_randkeys(::std::string* randkeys);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CRandCheckReq)
 private:
  inline void set_has_randkeys();
  inline void clear_has_randkeys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randkeys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckAck : public ::google::protobuf::Message {
 public:
  CRandCheckAck();
  virtual ~CRandCheckAck();

  CRandCheckAck(const CRandCheckAck& from);

  inline CRandCheckAck& operator=(const CRandCheckAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckAck& default_instance();

  void Swap(CRandCheckAck* other);

  // implements Message ----------------------------------------------

  CRandCheckAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckAck& from);
  void MergeFrom(const CRandCheckAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes keys = 1;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys() const;
  inline void set_keys(const ::std::string& value);
  inline void set_keys(const char* value);
  inline void set_keys(const void* value, size_t size);
  inline ::std::string* mutable_keys();
  inline ::std::string* release_keys();
  inline void set_allocated_keys(::std::string* keys);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CRandCheckAck)
 private:
  inline void set_has_keys();
  inline void clear_has_keys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckAck* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPing : public ::google::protobuf::Message {
 public:
  CHeartPing();
  virtual ~CHeartPing();

  CHeartPing(const CHeartPing& from);

  inline CHeartPing& operator=(const CHeartPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPing& default_instance();

  void Swap(CHeartPing* other);

  // implements Message ----------------------------------------------

  CHeartPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPing& from);
  void MergeFrom(const CHeartPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CHeartPing)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CHeartPing* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPingAck : public ::google::protobuf::Message {
 public:
  CHeartPingAck();
  virtual ~CHeartPingAck();

  CHeartPingAck(const CHeartPingAck& from);

  inline CHeartPingAck& operator=(const CHeartPingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPingAck& default_instance();

  void Swap(CHeartPingAck* other);

  // implements Message ----------------------------------------------

  CHeartPingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPingAck& from);
  void MergeFrom(const CHeartPingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CHeartPingAck)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CHeartPingAck* default_instance_;
};
// -------------------------------------------------------------------

class CheckNewNameReq : public ::google::protobuf::Message {
 public:
  CheckNewNameReq();
  virtual ~CheckNewNameReq();

  CheckNewNameReq(const CheckNewNameReq& from);

  inline CheckNewNameReq& operator=(const CheckNewNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckNewNameReq& default_instance();

  void Swap(CheckNewNameReq* other);

  // implements Message ----------------------------------------------

  CheckNewNameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckNewNameReq& from);
  void MergeFrom(const CheckNewNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional string newname = 2;
  inline bool has_newname() const;
  inline void clear_newname();
  static const int kNewnameFieldNumber = 2;
  inline const ::std::string& newname() const;
  inline void set_newname(const ::std::string& value);
  inline void set_newname(const char* value);
  inline void set_newname(const char* value, size_t size);
  inline ::std::string* mutable_newname();
  inline ::std::string* release_newname();
  inline void set_allocated_newname(::std::string* newname);

  // optional uint32 head_pic_id = 3;
  inline bool has_head_pic_id() const;
  inline void clear_head_pic_id();
  static const int kHeadPicIdFieldNumber = 3;
  inline ::google::protobuf::uint32 head_pic_id() const;
  inline void set_head_pic_id(::google::protobuf::uint32 value);

  // optional string gameserverid = 4;
  inline bool has_gameserverid() const;
  inline void clear_gameserverid();
  static const int kGameserveridFieldNumber = 4;
  inline const ::std::string& gameserverid() const;
  inline void set_gameserverid(const ::std::string& value);
  inline void set_gameserverid(const char* value);
  inline void set_gameserverid(const char* value, size_t size);
  inline ::std::string* mutable_gameserverid();
  inline ::std::string* release_gameserverid();
  inline void set_allocated_gameserverid(::std::string* gameserverid);

  // optional bool sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline bool sex() const;
  inline void set_sex(bool value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CheckNewNameReq)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_newname();
  inline void clear_has_newname();
  inline void set_has_head_pic_id();
  inline void clear_has_head_pic_id();
  inline void set_has_gameserverid();
  inline void clear_has_gameserverid();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* newname_;
  ::std::string* gameserverid_;
  ::google::protobuf::uint32 head_pic_id_;
  bool sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CheckNewNameReq* default_instance_;
};
// -------------------------------------------------------------------

class CheckNewNameAck : public ::google::protobuf::Message {
 public:
  CheckNewNameAck();
  virtual ~CheckNewNameAck();

  CheckNewNameAck(const CheckNewNameAck& from);

  inline CheckNewNameAck& operator=(const CheckNewNameAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckNewNameAck& default_instance();

  void Swap(CheckNewNameAck* other);

  // implements Message ----------------------------------------------

  CheckNewNameAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckNewNameAck& from);
  void MergeFrom(const CheckNewNameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional string newname = 2;
  inline bool has_newname() const;
  inline void clear_newname();
  static const int kNewnameFieldNumber = 2;
  inline const ::std::string& newname() const;
  inline void set_newname(const ::std::string& value);
  inline void set_newname(const char* value);
  inline void set_newname(const char* value, size_t size);
  inline ::std::string* mutable_newname();
  inline ::std::string* release_newname();
  inline void set_allocated_newname(::std::string* newname);

  // optional uint32 head_pic_id = 3;
  inline bool has_head_pic_id() const;
  inline void clear_head_pic_id();
  static const int kHeadPicIdFieldNumber = 3;
  inline ::google::protobuf::uint32 head_pic_id() const;
  inline void set_head_pic_id(::google::protobuf::uint32 value);

  // optional int32 error_no = 4;
  inline bool has_error_no() const;
  inline void clear_error_no();
  static const int kErrorNoFieldNumber = 4;
  inline ::google::protobuf::int32 error_no() const;
  inline void set_error_no(::google::protobuf::int32 value);

  // optional string gameserverid = 5;
  inline bool has_gameserverid() const;
  inline void clear_gameserverid();
  static const int kGameserveridFieldNumber = 5;
  inline const ::std::string& gameserverid() const;
  inline void set_gameserverid(const ::std::string& value);
  inline void set_gameserverid(const char* value);
  inline void set_gameserverid(const char* value, size_t size);
  inline ::std::string* mutable_gameserverid();
  inline ::std::string* release_gameserverid();
  inline void set_allocated_gameserverid(::std::string* gameserverid);

  // optional bool sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline bool sex() const;
  inline void set_sex(bool value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.CheckNewNameAck)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_newname();
  inline void clear_has_newname();
  inline void set_has_head_pic_id();
  inline void clear_has_head_pic_id();
  inline void set_has_error_no();
  inline void clear_has_error_no();
  inline void set_has_gameserverid();
  inline void clear_has_gameserverid();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* newname_;
  ::google::protobuf::uint32 head_pic_id_;
  ::google::protobuf::int32 error_no_;
  ::std::string* gameserverid_;
  bool sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static CheckNewNameAck* default_instance_;
};
// -------------------------------------------------------------------

class GetUniqueIDReq : public ::google::protobuf::Message {
 public:
  GetUniqueIDReq();
  virtual ~GetUniqueIDReq();

  GetUniqueIDReq(const GetUniqueIDReq& from);

  inline GetUniqueIDReq& operator=(const GetUniqueIDReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUniqueIDReq& default_instance();

  void Swap(GetUniqueIDReq* other);

  // implements Message ----------------------------------------------

  GetUniqueIDReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUniqueIDReq& from);
  void MergeFrom(const GetUniqueIDReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dbserverid = 1;
  inline bool has_dbserverid() const;
  inline void clear_dbserverid();
  static const int kDbserveridFieldNumber = 1;
  inline const ::std::string& dbserverid() const;
  inline void set_dbserverid(const ::std::string& value);
  inline void set_dbserverid(const char* value);
  inline void set_dbserverid(const char* value, size_t size);
  inline ::std::string* mutable_dbserverid();
  inline ::std::string* release_dbserverid();
  inline void set_allocated_dbserverid(::std::string* dbserverid);

  // optional string gameserverid = 2;
  inline bool has_gameserverid() const;
  inline void clear_gameserverid();
  static const int kGameserveridFieldNumber = 2;
  inline const ::std::string& gameserverid() const;
  inline void set_gameserverid(const ::std::string& value);
  inline void set_gameserverid(const char* value);
  inline void set_gameserverid(const char* value, size_t size);
  inline ::std::string* mutable_gameserverid();
  inline ::std::string* release_gameserverid();
  inline void set_allocated_gameserverid(::std::string* gameserverid);

  // optional uint32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.GetUniqueIDReq)
 private:
  inline void set_has_dbserverid();
  inline void clear_has_dbserverid();
  inline void set_has_gameserverid();
  inline void clear_has_gameserverid();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dbserverid_;
  ::std::string* gameserverid_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static GetUniqueIDReq* default_instance_;
};
// -------------------------------------------------------------------

class GetUniqueIDAck : public ::google::protobuf::Message {
 public:
  GetUniqueIDAck();
  virtual ~GetUniqueIDAck();

  GetUniqueIDAck(const GetUniqueIDAck& from);

  inline GetUniqueIDAck& operator=(const GetUniqueIDAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUniqueIDAck& default_instance();

  void Swap(GetUniqueIDAck* other);

  // implements Message ----------------------------------------------

  GetUniqueIDAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUniqueIDAck& from);
  void MergeFrom(const GetUniqueIDAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dbserverid = 1;
  inline bool has_dbserverid() const;
  inline void clear_dbserverid();
  static const int kDbserveridFieldNumber = 1;
  inline const ::std::string& dbserverid() const;
  inline void set_dbserverid(const ::std::string& value);
  inline void set_dbserverid(const char* value);
  inline void set_dbserverid(const char* value, size_t size);
  inline ::std::string* mutable_dbserverid();
  inline ::std::string* release_dbserverid();
  inline void set_allocated_dbserverid(::std::string* dbserverid);

  // optional string gameserverid = 2;
  inline bool has_gameserverid() const;
  inline void clear_gameserverid();
  static const int kGameserveridFieldNumber = 2;
  inline const ::std::string& gameserverid() const;
  inline void set_gameserverid(const ::std::string& value);
  inline void set_gameserverid(const char* value);
  inline void set_gameserverid(const char* value, size_t size);
  inline ::std::string* mutable_gameserverid();
  inline ::std::string* release_gameserverid();
  inline void set_allocated_gameserverid(::std::string* gameserverid);

  // optional uint64 begin_id = 3;
  inline bool has_begin_id() const;
  inline void clear_begin_id();
  static const int kBeginIdFieldNumber = 3;
  inline ::google::protobuf::uint64 begin_id() const;
  inline void set_begin_id(::google::protobuf::uint64 value);

  // optional uint64 end_id = 4;
  inline bool has_end_id() const;
  inline void clear_end_id();
  static const int kEndIdFieldNumber = 4;
  inline ::google::protobuf::uint64 end_id() const;
  inline void set_end_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.GetUniqueIDAck)
 private:
  inline void set_has_dbserverid();
  inline void clear_has_dbserverid();
  inline void set_has_gameserverid();
  inline void clear_has_gameserverid();
  inline void set_has_begin_id();
  inline void clear_has_begin_id();
  inline void set_has_end_id();
  inline void clear_has_end_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dbserverid_;
  ::std::string* gameserverid_;
  ::google::protobuf::uint64 begin_id_;
  ::google::protobuf::uint64 end_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static GetUniqueIDAck* default_instance_;
};
// -------------------------------------------------------------------

class ChongZhiPlayer : public ::google::protobuf::Message {
 public:
  ChongZhiPlayer();
  virtual ~ChongZhiPlayer();

  ChongZhiPlayer(const ChongZhiPlayer& from);

  inline ChongZhiPlayer& operator=(const ChongZhiPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChongZhiPlayer& default_instance();

  void Swap(ChongZhiPlayer* other);

  // implements Message ----------------------------------------------

  ChongZhiPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChongZhiPlayer& from);
  void MergeFrom(const ChongZhiPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // optional uint64 playerid = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 2;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.ChongZhiPlayer)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 transaction_id_;
  ::google::protobuf::uint64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static ChongZhiPlayer* default_instance_;
};
// -------------------------------------------------------------------

class ChongZhiNtf : public ::google::protobuf::Message {
 public:
  ChongZhiNtf();
  virtual ~ChongZhiNtf();

  ChongZhiNtf(const ChongZhiNtf& from);

  inline ChongZhiNtf& operator=(const ChongZhiNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChongZhiNtf& default_instance();

  void Swap(ChongZhiNtf* other);

  // implements Message ----------------------------------------------

  ChongZhiNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChongZhiNtf& from);
  void MergeFrom(const ChongZhiNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 area_no = 1;
  inline bool has_area_no() const;
  inline void clear_area_no();
  static const int kAreaNoFieldNumber = 1;
  inline ::google::protobuf::uint32 area_no() const;
  inline void set_area_no(::google::protobuf::uint32 value);

  // repeated .protoc.nsdb.ChongZhiPlayer chongzhi_user = 2;
  inline int chongzhi_user_size() const;
  inline void clear_chongzhi_user();
  static const int kChongzhiUserFieldNumber = 2;
  inline const ::protoc::nsdb::ChongZhiPlayer& chongzhi_user(int index) const;
  inline ::protoc::nsdb::ChongZhiPlayer* mutable_chongzhi_user(int index);
  inline ::protoc::nsdb::ChongZhiPlayer* add_chongzhi_user();
  inline const ::google::protobuf::RepeatedPtrField< ::protoc::nsdb::ChongZhiPlayer >&
      chongzhi_user() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoc::nsdb::ChongZhiPlayer >*
      mutable_chongzhi_user();

  // @@protoc_insertion_point(class_scope:protoc.nsdb.ChongZhiNtf)
 private:
  inline void set_has_area_no();
  inline void clear_has_area_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protoc::nsdb::ChongZhiPlayer > chongzhi_user_;
  ::google::protobuf::uint32 area_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static ChongZhiNtf* default_instance_;
};
// -------------------------------------------------------------------

class report_online_number : public ::google::protobuf::Message {
 public:
  report_online_number();
  virtual ~report_online_number();

  report_online_number(const report_online_number& from);

  inline report_online_number& operator=(const report_online_number& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const report_online_number& default_instance();

  void Swap(report_online_number* other);

  // implements Message ----------------------------------------------

  report_online_number* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const report_online_number& from);
  void MergeFrom(const report_online_number& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 area_no = 1;
  inline bool has_area_no() const;
  inline void clear_area_no();
  static const int kAreaNoFieldNumber = 1;
  inline ::google::protobuf::int32 area_no() const;
  inline void set_area_no(::google::protobuf::int32 value);

  // optional int32 total_number = 2;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 2;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.report_online_number)
 private:
  inline void set_has_area_no();
  inline void clear_has_area_no();
  inline void set_has_total_number();
  inline void clear_has_total_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 area_no_;
  ::google::protobuf::int32 total_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static report_online_number* default_instance_;
};
// -------------------------------------------------------------------

class GameImportLogRpt : public ::google::protobuf::Message {
 public:
  GameImportLogRpt();
  virtual ~GameImportLogRpt();

  GameImportLogRpt(const GameImportLogRpt& from);

  inline GameImportLogRpt& operator=(const GameImportLogRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameImportLogRpt& default_instance();

  void Swap(GameImportLogRpt* other);

  // implements Message ----------------------------------------------

  GameImportLogRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameImportLogRpt& from);
  void MergeFrom(const GameImportLogRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint32 aread_no = 2;
  inline bool has_aread_no() const;
  inline void clear_aread_no();
  static const int kAreadNoFieldNumber = 2;
  inline ::google::protobuf::uint32 aread_no() const;
  inline void set_aread_no(::google::protobuf::uint32 value);

  // optional uint32 server_kind = 3;
  inline bool has_server_kind() const;
  inline void clear_server_kind();
  static const int kServerKindFieldNumber = 3;
  inline ::google::protobuf::uint32 server_kind() const;
  inline void set_server_kind(::google::protobuf::uint32 value);

  // optional uint32 server_no = 4;
  inline bool has_server_no() const;
  inline void clear_server_no();
  static const int kServerNoFieldNumber = 4;
  inline ::google::protobuf::uint32 server_no() const;
  inline void set_server_no(::google::protobuf::uint32 value);

  // optional string account = 5;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 5;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint64 playerid = 6;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 6;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string playername = 7;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayernameFieldNumber = 7;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // optional string msg = 8;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 8;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.GameImportLogRpt)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_aread_no();
  inline void clear_has_aread_no();
  inline void set_has_server_kind();
  inline void clear_has_server_kind();
  inline void set_has_server_no();
  inline void clear_has_server_no();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 aread_no_;
  ::google::protobuf::uint32 server_kind_;
  ::google::protobuf::uint32 server_no_;
  ::std::string* account_;
  ::google::protobuf::uint64 playerid_;
  ::std::string* playername_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static GameImportLogRpt* default_instance_;
};
// -------------------------------------------------------------------

class GameServerMessageTransNtf : public ::google::protobuf::Message {
 public:
  GameServerMessageTransNtf();
  virtual ~GameServerMessageTransNtf();

  GameServerMessageTransNtf(const GameServerMessageTransNtf& from);

  inline GameServerMessageTransNtf& operator=(const GameServerMessageTransNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerMessageTransNtf& default_instance();

  void Swap(GameServerMessageTransNtf* other);

  // implements Message ----------------------------------------------

  GameServerMessageTransNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameServerMessageTransNtf& from);
  void MergeFrom(const GameServerMessageTransNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .protoc.nsdb.E_GS_TRANS_TYPE trans_kind = 2;
  inline bool has_trans_kind() const;
  inline void clear_trans_kind();
  static const int kTransKindFieldNumber = 2;
  inline ::protoc::nsdb::E_GS_TRANS_TYPE trans_kind() const;
  inline void set_trans_kind(::protoc::nsdb::E_GS_TRANS_TYPE value);

  // optional bytes msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional string target_gs = 4;
  inline bool has_target_gs() const;
  inline void clear_target_gs();
  static const int kTargetGsFieldNumber = 4;
  inline const ::std::string& target_gs() const;
  inline void set_target_gs(const ::std::string& value);
  inline void set_target_gs(const char* value);
  inline void set_target_gs(const char* value, size_t size);
  inline ::std::string* mutable_target_gs();
  inline ::std::string* release_target_gs();
  inline void set_allocated_target_gs(::std::string* target_gs);

  // optional uint32 area_id = 5;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 5;
  inline ::google::protobuf::uint32 area_id() const;
  inline void set_area_id(::google::protobuf::uint32 value);

  // optional string area_name = 6;
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 6;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  inline void set_allocated_area_name(::std::string* area_name);

  // @@protoc_insertion_point(class_scope:protoc.nsdb.GameServerMessageTransNtf)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_trans_kind();
  inline void clear_has_trans_kind();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_target_gs();
  inline void clear_has_target_gs();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_area_name();
  inline void clear_has_area_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  int trans_kind_;
  ::std::string* msg_;
  ::std::string* target_gs_;
  ::std::string* area_name_;
  ::google::protobuf::uint32 area_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ns_2edb_2eproto();
  friend void protobuf_AssignDesc_ns_2edb_2eproto();
  friend void protobuf_ShutdownFile_ns_2edb_2eproto();

  void InitAsDefaultInstance();
  static GameServerMessageTransNtf* default_instance_;
};
// ===================================================================


// ===================================================================

// CDBServerInfoRpt

// optional string id = 1;
inline bool CDBServerInfoRpt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDBServerInfoRpt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDBServerInfoRpt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDBServerInfoRpt::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CDBServerInfoRpt::id() const {
  return *id_;
}
inline void CDBServerInfoRpt::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CDBServerInfoRpt::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CDBServerInfoRpt::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDBServerInfoRpt::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CDBServerInfoRpt::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDBServerInfoRpt::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CDBServerInfoRpt::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDBServerInfoRpt::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDBServerInfoRpt::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDBServerInfoRpt::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CDBServerInfoRpt::name() const {
  return *name_;
}
inline void CDBServerInfoRpt::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CDBServerInfoRpt::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CDBServerInfoRpt::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDBServerInfoRpt::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CDBServerInfoRpt::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDBServerInfoRpt::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CNameServerInfoRpt

// optional string id = 1;
inline bool CNameServerInfoRpt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CNameServerInfoRpt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CNameServerInfoRpt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CNameServerInfoRpt::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CNameServerInfoRpt::id() const {
  return *id_;
}
inline void CNameServerInfoRpt::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CNameServerInfoRpt::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CNameServerInfoRpt::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CNameServerInfoRpt::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CNameServerInfoRpt::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CNameServerInfoRpt::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CNameServerInfoRpt::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CNameServerInfoRpt::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CNameServerInfoRpt::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CNameServerInfoRpt::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CNameServerInfoRpt::name() const {
  return *name_;
}
inline void CNameServerInfoRpt::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CNameServerInfoRpt::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CNameServerInfoRpt::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CNameServerInfoRpt::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CNameServerInfoRpt::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CNameServerInfoRpt::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRandCheckReq

// optional bytes randkeys = 1;
inline bool CRandCheckReq::has_randkeys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckReq::set_has_randkeys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckReq::clear_has_randkeys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckReq::clear_randkeys() {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    randkeys_->clear();
  }
  clear_has_randkeys();
}
inline const ::std::string& CRandCheckReq::randkeys() const {
  return *randkeys_;
}
inline void CRandCheckReq::set_randkeys(const ::std::string& value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const char* value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const void* value, size_t size) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckReq::mutable_randkeys() {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  return randkeys_;
}
inline ::std::string* CRandCheckReq::release_randkeys() {
  clear_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randkeys_;
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckReq::set_allocated_randkeys(::std::string* randkeys) {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    delete randkeys_;
  }
  if (randkeys) {
    set_has_randkeys();
    randkeys_ = randkeys;
  } else {
    clear_has_randkeys();
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRandCheckAck

// optional bytes keys = 1;
inline bool CRandCheckAck::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckAck::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckAck::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckAck::clear_keys() {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    keys_->clear();
  }
  clear_has_keys();
}
inline const ::std::string& CRandCheckAck::keys() const {
  return *keys_;
}
inline void CRandCheckAck::set_keys(const ::std::string& value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const char* value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const void* value, size_t size) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckAck::mutable_keys() {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  return keys_;
}
inline ::std::string* CRandCheckAck::release_keys() {
  clear_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keys_;
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckAck::set_allocated_keys(::std::string* keys) {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    delete keys_;
  }
  if (keys) {
    set_has_keys();
    keys_ = keys;
  } else {
    clear_has_keys();
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CHeartPing

// optional int32 opt = 1;
inline bool CHeartPing::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPing::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPing::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPing::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPing::opt() const {
  return opt_;
}
inline void CHeartPing::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// CHeartPingAck

// optional int32 opt = 1;
inline bool CHeartPingAck::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPingAck::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPingAck::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPingAck::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPingAck::opt() const {
  return opt_;
}
inline void CHeartPingAck::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// CheckNewNameReq

// optional uint64 digit_account = 1;
inline bool CheckNewNameReq::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckNewNameReq::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckNewNameReq::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckNewNameReq::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 CheckNewNameReq::digit_account() const {
  return digit_account_;
}
inline void CheckNewNameReq::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional string newname = 2;
inline bool CheckNewNameReq::has_newname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckNewNameReq::set_has_newname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckNewNameReq::clear_has_newname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckNewNameReq::clear_newname() {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    newname_->clear();
  }
  clear_has_newname();
}
inline const ::std::string& CheckNewNameReq::newname() const {
  return *newname_;
}
inline void CheckNewNameReq::set_newname(const ::std::string& value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CheckNewNameReq::set_newname(const char* value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CheckNewNameReq::set_newname(const char* value, size_t size) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNewNameReq::mutable_newname() {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  return newname_;
}
inline ::std::string* CheckNewNameReq::release_newname() {
  clear_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newname_;
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNewNameReq::set_allocated_newname(::std::string* newname) {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    delete newname_;
  }
  if (newname) {
    set_has_newname();
    newname_ = newname;
  } else {
    clear_has_newname();
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 head_pic_id = 3;
inline bool CheckNewNameReq::has_head_pic_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckNewNameReq::set_has_head_pic_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckNewNameReq::clear_has_head_pic_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckNewNameReq::clear_head_pic_id() {
  head_pic_id_ = 0u;
  clear_has_head_pic_id();
}
inline ::google::protobuf::uint32 CheckNewNameReq::head_pic_id() const {
  return head_pic_id_;
}
inline void CheckNewNameReq::set_head_pic_id(::google::protobuf::uint32 value) {
  set_has_head_pic_id();
  head_pic_id_ = value;
}

// optional string gameserverid = 4;
inline bool CheckNewNameReq::has_gameserverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckNewNameReq::set_has_gameserverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckNewNameReq::clear_has_gameserverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckNewNameReq::clear_gameserverid() {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    gameserverid_->clear();
  }
  clear_has_gameserverid();
}
inline const ::std::string& CheckNewNameReq::gameserverid() const {
  return *gameserverid_;
}
inline void CheckNewNameReq::set_gameserverid(const ::std::string& value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void CheckNewNameReq::set_gameserverid(const char* value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void CheckNewNameReq::set_gameserverid(const char* value, size_t size) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNewNameReq::mutable_gameserverid() {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  return gameserverid_;
}
inline ::std::string* CheckNewNameReq::release_gameserverid() {
  clear_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverid_;
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNewNameReq::set_allocated_gameserverid(::std::string* gameserverid) {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameserverid_;
  }
  if (gameserverid) {
    set_has_gameserverid();
    gameserverid_ = gameserverid;
  } else {
    clear_has_gameserverid();
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool sex = 5;
inline bool CheckNewNameReq::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckNewNameReq::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckNewNameReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckNewNameReq::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool CheckNewNameReq::sex() const {
  return sex_;
}
inline void CheckNewNameReq::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// CheckNewNameAck

// optional uint64 digit_account = 1;
inline bool CheckNewNameAck::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckNewNameAck::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckNewNameAck::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckNewNameAck::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 CheckNewNameAck::digit_account() const {
  return digit_account_;
}
inline void CheckNewNameAck::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional string newname = 2;
inline bool CheckNewNameAck::has_newname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckNewNameAck::set_has_newname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckNewNameAck::clear_has_newname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckNewNameAck::clear_newname() {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    newname_->clear();
  }
  clear_has_newname();
}
inline const ::std::string& CheckNewNameAck::newname() const {
  return *newname_;
}
inline void CheckNewNameAck::set_newname(const ::std::string& value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CheckNewNameAck::set_newname(const char* value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CheckNewNameAck::set_newname(const char* value, size_t size) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNewNameAck::mutable_newname() {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  return newname_;
}
inline ::std::string* CheckNewNameAck::release_newname() {
  clear_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newname_;
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNewNameAck::set_allocated_newname(::std::string* newname) {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    delete newname_;
  }
  if (newname) {
    set_has_newname();
    newname_ = newname;
  } else {
    clear_has_newname();
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 head_pic_id = 3;
inline bool CheckNewNameAck::has_head_pic_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckNewNameAck::set_has_head_pic_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckNewNameAck::clear_has_head_pic_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckNewNameAck::clear_head_pic_id() {
  head_pic_id_ = 0u;
  clear_has_head_pic_id();
}
inline ::google::protobuf::uint32 CheckNewNameAck::head_pic_id() const {
  return head_pic_id_;
}
inline void CheckNewNameAck::set_head_pic_id(::google::protobuf::uint32 value) {
  set_has_head_pic_id();
  head_pic_id_ = value;
}

// optional int32 error_no = 4;
inline bool CheckNewNameAck::has_error_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckNewNameAck::set_has_error_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckNewNameAck::clear_has_error_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckNewNameAck::clear_error_no() {
  error_no_ = 0;
  clear_has_error_no();
}
inline ::google::protobuf::int32 CheckNewNameAck::error_no() const {
  return error_no_;
}
inline void CheckNewNameAck::set_error_no(::google::protobuf::int32 value) {
  set_has_error_no();
  error_no_ = value;
}

// optional string gameserverid = 5;
inline bool CheckNewNameAck::has_gameserverid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckNewNameAck::set_has_gameserverid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckNewNameAck::clear_has_gameserverid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckNewNameAck::clear_gameserverid() {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    gameserverid_->clear();
  }
  clear_has_gameserverid();
}
inline const ::std::string& CheckNewNameAck::gameserverid() const {
  return *gameserverid_;
}
inline void CheckNewNameAck::set_gameserverid(const ::std::string& value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void CheckNewNameAck::set_gameserverid(const char* value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void CheckNewNameAck::set_gameserverid(const char* value, size_t size) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNewNameAck::mutable_gameserverid() {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  return gameserverid_;
}
inline ::std::string* CheckNewNameAck::release_gameserverid() {
  clear_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverid_;
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNewNameAck::set_allocated_gameserverid(::std::string* gameserverid) {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameserverid_;
  }
  if (gameserverid) {
    set_has_gameserverid();
    gameserverid_ = gameserverid;
  } else {
    clear_has_gameserverid();
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool sex = 6;
inline bool CheckNewNameAck::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckNewNameAck::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckNewNameAck::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckNewNameAck::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool CheckNewNameAck::sex() const {
  return sex_;
}
inline void CheckNewNameAck::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// GetUniqueIDReq

// optional string dbserverid = 1;
inline bool GetUniqueIDReq::has_dbserverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUniqueIDReq::set_has_dbserverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUniqueIDReq::clear_has_dbserverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUniqueIDReq::clear_dbserverid() {
  if (dbserverid_ != &::google::protobuf::internal::kEmptyString) {
    dbserverid_->clear();
  }
  clear_has_dbserverid();
}
inline const ::std::string& GetUniqueIDReq::dbserverid() const {
  return *dbserverid_;
}
inline void GetUniqueIDReq::set_dbserverid(const ::std::string& value) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(value);
}
inline void GetUniqueIDReq::set_dbserverid(const char* value) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(value);
}
inline void GetUniqueIDReq::set_dbserverid(const char* value, size_t size) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUniqueIDReq::mutable_dbserverid() {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  return dbserverid_;
}
inline ::std::string* GetUniqueIDReq::release_dbserverid() {
  clear_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbserverid_;
    dbserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUniqueIDReq::set_allocated_dbserverid(::std::string* dbserverid) {
  if (dbserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete dbserverid_;
  }
  if (dbserverid) {
    set_has_dbserverid();
    dbserverid_ = dbserverid;
  } else {
    clear_has_dbserverid();
    dbserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gameserverid = 2;
inline bool GetUniqueIDReq::has_gameserverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUniqueIDReq::set_has_gameserverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUniqueIDReq::clear_has_gameserverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUniqueIDReq::clear_gameserverid() {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    gameserverid_->clear();
  }
  clear_has_gameserverid();
}
inline const ::std::string& GetUniqueIDReq::gameserverid() const {
  return *gameserverid_;
}
inline void GetUniqueIDReq::set_gameserverid(const ::std::string& value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void GetUniqueIDReq::set_gameserverid(const char* value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void GetUniqueIDReq::set_gameserverid(const char* value, size_t size) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUniqueIDReq::mutable_gameserverid() {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  return gameserverid_;
}
inline ::std::string* GetUniqueIDReq::release_gameserverid() {
  clear_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverid_;
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUniqueIDReq::set_allocated_gameserverid(::std::string* gameserverid) {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameserverid_;
  }
  if (gameserverid) {
    set_has_gameserverid();
    gameserverid_ = gameserverid;
  } else {
    clear_has_gameserverid();
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 number = 3;
inline bool GetUniqueIDReq::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUniqueIDReq::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUniqueIDReq::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUniqueIDReq::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 GetUniqueIDReq::number() const {
  return number_;
}
inline void GetUniqueIDReq::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// GetUniqueIDAck

// optional string dbserverid = 1;
inline bool GetUniqueIDAck::has_dbserverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUniqueIDAck::set_has_dbserverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUniqueIDAck::clear_has_dbserverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUniqueIDAck::clear_dbserverid() {
  if (dbserverid_ != &::google::protobuf::internal::kEmptyString) {
    dbserverid_->clear();
  }
  clear_has_dbserverid();
}
inline const ::std::string& GetUniqueIDAck::dbserverid() const {
  return *dbserverid_;
}
inline void GetUniqueIDAck::set_dbserverid(const ::std::string& value) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(value);
}
inline void GetUniqueIDAck::set_dbserverid(const char* value) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(value);
}
inline void GetUniqueIDAck::set_dbserverid(const char* value, size_t size) {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  dbserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUniqueIDAck::mutable_dbserverid() {
  set_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    dbserverid_ = new ::std::string;
  }
  return dbserverid_;
}
inline ::std::string* GetUniqueIDAck::release_dbserverid() {
  clear_has_dbserverid();
  if (dbserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbserverid_;
    dbserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUniqueIDAck::set_allocated_dbserverid(::std::string* dbserverid) {
  if (dbserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete dbserverid_;
  }
  if (dbserverid) {
    set_has_dbserverid();
    dbserverid_ = dbserverid;
  } else {
    clear_has_dbserverid();
    dbserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gameserverid = 2;
inline bool GetUniqueIDAck::has_gameserverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUniqueIDAck::set_has_gameserverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUniqueIDAck::clear_has_gameserverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUniqueIDAck::clear_gameserverid() {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    gameserverid_->clear();
  }
  clear_has_gameserverid();
}
inline const ::std::string& GetUniqueIDAck::gameserverid() const {
  return *gameserverid_;
}
inline void GetUniqueIDAck::set_gameserverid(const ::std::string& value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void GetUniqueIDAck::set_gameserverid(const char* value) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(value);
}
inline void GetUniqueIDAck::set_gameserverid(const char* value, size_t size) {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  gameserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUniqueIDAck::mutable_gameserverid() {
  set_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    gameserverid_ = new ::std::string;
  }
  return gameserverid_;
}
inline ::std::string* GetUniqueIDAck::release_gameserverid() {
  clear_has_gameserverid();
  if (gameserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserverid_;
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUniqueIDAck::set_allocated_gameserverid(::std::string* gameserverid) {
  if (gameserverid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameserverid_;
  }
  if (gameserverid) {
    set_has_gameserverid();
    gameserverid_ = gameserverid;
  } else {
    clear_has_gameserverid();
    gameserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 begin_id = 3;
inline bool GetUniqueIDAck::has_begin_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUniqueIDAck::set_has_begin_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUniqueIDAck::clear_has_begin_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUniqueIDAck::clear_begin_id() {
  begin_id_ = GOOGLE_ULONGLONG(0);
  clear_has_begin_id();
}
inline ::google::protobuf::uint64 GetUniqueIDAck::begin_id() const {
  return begin_id_;
}
inline void GetUniqueIDAck::set_begin_id(::google::protobuf::uint64 value) {
  set_has_begin_id();
  begin_id_ = value;
}

// optional uint64 end_id = 4;
inline bool GetUniqueIDAck::has_end_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUniqueIDAck::set_has_end_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUniqueIDAck::clear_has_end_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUniqueIDAck::clear_end_id() {
  end_id_ = GOOGLE_ULONGLONG(0);
  clear_has_end_id();
}
inline ::google::protobuf::uint64 GetUniqueIDAck::end_id() const {
  return end_id_;
}
inline void GetUniqueIDAck::set_end_id(::google::protobuf::uint64 value) {
  set_has_end_id();
  end_id_ = value;
}

// -------------------------------------------------------------------

// ChongZhiPlayer

// optional uint64 transaction_id = 1;
inline bool ChongZhiPlayer::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChongZhiPlayer::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChongZhiPlayer::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChongZhiPlayer::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 ChongZhiPlayer::transaction_id() const {
  return transaction_id_;
}
inline void ChongZhiPlayer::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional uint64 playerid = 2;
inline bool ChongZhiPlayer::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChongZhiPlayer::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChongZhiPlayer::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChongZhiPlayer::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 ChongZhiPlayer::playerid() const {
  return playerid_;
}
inline void ChongZhiPlayer::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// ChongZhiNtf

// optional uint32 area_no = 1;
inline bool ChongZhiNtf::has_area_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChongZhiNtf::set_has_area_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChongZhiNtf::clear_has_area_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChongZhiNtf::clear_area_no() {
  area_no_ = 0u;
  clear_has_area_no();
}
inline ::google::protobuf::uint32 ChongZhiNtf::area_no() const {
  return area_no_;
}
inline void ChongZhiNtf::set_area_no(::google::protobuf::uint32 value) {
  set_has_area_no();
  area_no_ = value;
}

// repeated .protoc.nsdb.ChongZhiPlayer chongzhi_user = 2;
inline int ChongZhiNtf::chongzhi_user_size() const {
  return chongzhi_user_.size();
}
inline void ChongZhiNtf::clear_chongzhi_user() {
  chongzhi_user_.Clear();
}
inline const ::protoc::nsdb::ChongZhiPlayer& ChongZhiNtf::chongzhi_user(int index) const {
  return chongzhi_user_.Get(index);
}
inline ::protoc::nsdb::ChongZhiPlayer* ChongZhiNtf::mutable_chongzhi_user(int index) {
  return chongzhi_user_.Mutable(index);
}
inline ::protoc::nsdb::ChongZhiPlayer* ChongZhiNtf::add_chongzhi_user() {
  return chongzhi_user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoc::nsdb::ChongZhiPlayer >&
ChongZhiNtf::chongzhi_user() const {
  return chongzhi_user_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoc::nsdb::ChongZhiPlayer >*
ChongZhiNtf::mutable_chongzhi_user() {
  return &chongzhi_user_;
}

// -------------------------------------------------------------------

// report_online_number

// optional int32 area_no = 1;
inline bool report_online_number::has_area_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void report_online_number::set_has_area_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void report_online_number::clear_has_area_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void report_online_number::clear_area_no() {
  area_no_ = 0;
  clear_has_area_no();
}
inline ::google::protobuf::int32 report_online_number::area_no() const {
  return area_no_;
}
inline void report_online_number::set_area_no(::google::protobuf::int32 value) {
  set_has_area_no();
  area_no_ = value;
}

// optional int32 total_number = 2;
inline bool report_online_number::has_total_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void report_online_number::set_has_total_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void report_online_number::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void report_online_number::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 report_online_number::total_number() const {
  return total_number_;
}
inline void report_online_number::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
}

// -------------------------------------------------------------------

// GameImportLogRpt

// optional uint32 event_id = 1;
inline bool GameImportLogRpt::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameImportLogRpt::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameImportLogRpt::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameImportLogRpt::clear_event_id() {
  event_id_ = 0u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 GameImportLogRpt::event_id() const {
  return event_id_;
}
inline void GameImportLogRpt::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 aread_no = 2;
inline bool GameImportLogRpt::has_aread_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameImportLogRpt::set_has_aread_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameImportLogRpt::clear_has_aread_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameImportLogRpt::clear_aread_no() {
  aread_no_ = 0u;
  clear_has_aread_no();
}
inline ::google::protobuf::uint32 GameImportLogRpt::aread_no() const {
  return aread_no_;
}
inline void GameImportLogRpt::set_aread_no(::google::protobuf::uint32 value) {
  set_has_aread_no();
  aread_no_ = value;
}

// optional uint32 server_kind = 3;
inline bool GameImportLogRpt::has_server_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameImportLogRpt::set_has_server_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameImportLogRpt::clear_has_server_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameImportLogRpt::clear_server_kind() {
  server_kind_ = 0u;
  clear_has_server_kind();
}
inline ::google::protobuf::uint32 GameImportLogRpt::server_kind() const {
  return server_kind_;
}
inline void GameImportLogRpt::set_server_kind(::google::protobuf::uint32 value) {
  set_has_server_kind();
  server_kind_ = value;
}

// optional uint32 server_no = 4;
inline bool GameImportLogRpt::has_server_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameImportLogRpt::set_has_server_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameImportLogRpt::clear_has_server_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameImportLogRpt::clear_server_no() {
  server_no_ = 0u;
  clear_has_server_no();
}
inline ::google::protobuf::uint32 GameImportLogRpt::server_no() const {
  return server_no_;
}
inline void GameImportLogRpt::set_server_no(::google::protobuf::uint32 value) {
  set_has_server_no();
  server_no_ = value;
}

// optional string account = 5;
inline bool GameImportLogRpt::has_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameImportLogRpt::set_has_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameImportLogRpt::clear_has_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameImportLogRpt::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& GameImportLogRpt::account() const {
  return *account_;
}
inline void GameImportLogRpt::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GameImportLogRpt::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GameImportLogRpt::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameImportLogRpt::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* GameImportLogRpt::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameImportLogRpt::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 playerid = 6;
inline bool GameImportLogRpt::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameImportLogRpt::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameImportLogRpt::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameImportLogRpt::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 GameImportLogRpt::playerid() const {
  return playerid_;
}
inline void GameImportLogRpt::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string playername = 7;
inline bool GameImportLogRpt::has_playername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameImportLogRpt::set_has_playername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameImportLogRpt::clear_has_playername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameImportLogRpt::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& GameImportLogRpt::playername() const {
  return *playername_;
}
inline void GameImportLogRpt::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void GameImportLogRpt::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void GameImportLogRpt::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameImportLogRpt::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* GameImportLogRpt::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameImportLogRpt::set_allocated_playername(::std::string* playername) {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string msg = 8;
inline bool GameImportLogRpt::has_msg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameImportLogRpt::set_has_msg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameImportLogRpt::clear_has_msg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameImportLogRpt::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& GameImportLogRpt::msg() const {
  return *msg_;
}
inline void GameImportLogRpt::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GameImportLogRpt::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GameImportLogRpt::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameImportLogRpt::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* GameImportLogRpt::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameImportLogRpt::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameServerMessageTransNtf

// optional uint32 id = 1;
inline bool GameServerMessageTransNtf::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerMessageTransNtf::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerMessageTransNtf::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerMessageTransNtf::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 GameServerMessageTransNtf::id() const {
  return id_;
}
inline void GameServerMessageTransNtf::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .protoc.nsdb.E_GS_TRANS_TYPE trans_kind = 2;
inline bool GameServerMessageTransNtf::has_trans_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerMessageTransNtf::set_has_trans_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerMessageTransNtf::clear_has_trans_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerMessageTransNtf::clear_trans_kind() {
  trans_kind_ = 1;
  clear_has_trans_kind();
}
inline ::protoc::nsdb::E_GS_TRANS_TYPE GameServerMessageTransNtf::trans_kind() const {
  return static_cast< ::protoc::nsdb::E_GS_TRANS_TYPE >(trans_kind_);
}
inline void GameServerMessageTransNtf::set_trans_kind(::protoc::nsdb::E_GS_TRANS_TYPE value) {
  assert(::protoc::nsdb::E_GS_TRANS_TYPE_IsValid(value));
  set_has_trans_kind();
  trans_kind_ = value;
}

// optional bytes msg = 3;
inline bool GameServerMessageTransNtf::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameServerMessageTransNtf::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameServerMessageTransNtf::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameServerMessageTransNtf::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& GameServerMessageTransNtf::msg() const {
  return *msg_;
}
inline void GameServerMessageTransNtf::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GameServerMessageTransNtf::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GameServerMessageTransNtf::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameServerMessageTransNtf::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* GameServerMessageTransNtf::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameServerMessageTransNtf::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target_gs = 4;
inline bool GameServerMessageTransNtf::has_target_gs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameServerMessageTransNtf::set_has_target_gs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameServerMessageTransNtf::clear_has_target_gs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameServerMessageTransNtf::clear_target_gs() {
  if (target_gs_ != &::google::protobuf::internal::kEmptyString) {
    target_gs_->clear();
  }
  clear_has_target_gs();
}
inline const ::std::string& GameServerMessageTransNtf::target_gs() const {
  return *target_gs_;
}
inline void GameServerMessageTransNtf::set_target_gs(const ::std::string& value) {
  set_has_target_gs();
  if (target_gs_ == &::google::protobuf::internal::kEmptyString) {
    target_gs_ = new ::std::string;
  }
  target_gs_->assign(value);
}
inline void GameServerMessageTransNtf::set_target_gs(const char* value) {
  set_has_target_gs();
  if (target_gs_ == &::google::protobuf::internal::kEmptyString) {
    target_gs_ = new ::std::string;
  }
  target_gs_->assign(value);
}
inline void GameServerMessageTransNtf::set_target_gs(const char* value, size_t size) {
  set_has_target_gs();
  if (target_gs_ == &::google::protobuf::internal::kEmptyString) {
    target_gs_ = new ::std::string;
  }
  target_gs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameServerMessageTransNtf::mutable_target_gs() {
  set_has_target_gs();
  if (target_gs_ == &::google::protobuf::internal::kEmptyString) {
    target_gs_ = new ::std::string;
  }
  return target_gs_;
}
inline ::std::string* GameServerMessageTransNtf::release_target_gs() {
  clear_has_target_gs();
  if (target_gs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_gs_;
    target_gs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameServerMessageTransNtf::set_allocated_target_gs(::std::string* target_gs) {
  if (target_gs_ != &::google::protobuf::internal::kEmptyString) {
    delete target_gs_;
  }
  if (target_gs) {
    set_has_target_gs();
    target_gs_ = target_gs;
  } else {
    clear_has_target_gs();
    target_gs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 area_id = 5;
inline bool GameServerMessageTransNtf::has_area_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameServerMessageTransNtf::set_has_area_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameServerMessageTransNtf::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameServerMessageTransNtf::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 GameServerMessageTransNtf::area_id() const {
  return area_id_;
}
inline void GameServerMessageTransNtf::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional string area_name = 6;
inline bool GameServerMessageTransNtf::has_area_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameServerMessageTransNtf::set_has_area_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameServerMessageTransNtf::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameServerMessageTransNtf::clear_area_name() {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    area_name_->clear();
  }
  clear_has_area_name();
}
inline const ::std::string& GameServerMessageTransNtf::area_name() const {
  return *area_name_;
}
inline void GameServerMessageTransNtf::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void GameServerMessageTransNtf::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void GameServerMessageTransNtf::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameServerMessageTransNtf::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}
inline ::std::string* GameServerMessageTransNtf::release_area_name() {
  clear_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameServerMessageTransNtf::set_allocated_area_name(::std::string* area_name) {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    delete area_name_;
  }
  if (area_name) {
    set_has_area_name();
    area_name_ = area_name;
  } else {
    clear_has_area_name();
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsdb
}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoc::nsdb::E_GS_TRANS_TYPE>() {
  return ::protoc::nsdb::E_GS_TRANS_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ns_2edb_2eproto__INCLUDED
