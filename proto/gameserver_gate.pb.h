// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameserver_gate.proto

#ifndef PROTOBUF_gameserver_5fgate_2eproto__INCLUDED
#define PROTOBUF_gameserver_5fgate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protoc {
namespace gameserver_gate {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameserver_5fgate_2eproto();
void protobuf_AssignDesc_gameserver_5fgate_2eproto();
void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

class CGameServerReport;
class CGateServerReport;
class CGateTransClientMsg;
class CGateTransGameServerMsg;
class NewPlayerEnterGameReq;
class NewPlayerEnterGameAck;
class PlayerTerminateGateRpt;
class KickOutPlayerRpt;
class CRandCheckReq;
class CRandCheckAck;
class CHeartPing;
class CHeartPingAck;
class PlayerSwitchGSReq;
class PlayerSwitchGSAck;
class PlayerReLoginReq;
class PlayerReLoginAck;
class GateCloseNtf;
class login_gt_req;
class login_gt_ack;
class client_number_rpt;
class client_login_gate_time_out_rpt;

// ===================================================================

class CGameServerReport : public ::google::protobuf::Message {
 public:
  CGameServerReport();
  virtual ~CGameServerReport();

  CGameServerReport(const CGameServerReport& from);

  inline CGameServerReport& operator=(const CGameServerReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGameServerReport& default_instance();

  void Swap(CGameServerReport* other);

  // implements Message ----------------------------------------------

  CGameServerReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGameServerReport& from);
  void MergeFrom(const CGameServerReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 online_number = 3;
  inline bool has_online_number() const;
  inline void clear_online_number();
  static const int kOnlineNumberFieldNumber = 3;
  inline ::google::protobuf::int32 online_number() const;
  inline void set_online_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CGameServerReport)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_online_number();
  inline void clear_has_online_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 online_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CGameServerReport* default_instance_;
};
// -------------------------------------------------------------------

class CGateServerReport : public ::google::protobuf::Message {
 public:
  CGateServerReport();
  virtual ~CGateServerReport();

  CGateServerReport(const CGateServerReport& from);

  inline CGateServerReport& operator=(const CGateServerReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGateServerReport& default_instance();

  void Swap(CGateServerReport* other);

  // implements Message ----------------------------------------------

  CGateServerReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGateServerReport& from);
  void MergeFrom(const CGateServerReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CGateServerReport)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CGateServerReport* default_instance_;
};
// -------------------------------------------------------------------

class CGateTransClientMsg : public ::google::protobuf::Message {
 public:
  CGateTransClientMsg();
  virtual ~CGateTransClientMsg();

  CGateTransClientMsg(const CGateTransClientMsg& from);

  inline CGateTransClientMsg& operator=(const CGateTransClientMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGateTransClientMsg& default_instance();

  void Swap(CGateTransClientMsg* other);

  // implements Message ----------------------------------------------

  CGateTransClientMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGateTransClientMsg& from);
  void MergeFrom(const CGateTransClientMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_session_id = 1;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional bytes msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CGateTransClientMsg)
 private:
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::uint32 client_session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CGateTransClientMsg* default_instance_;
};
// -------------------------------------------------------------------

class CGateTransGameServerMsg : public ::google::protobuf::Message {
 public:
  CGateTransGameServerMsg();
  virtual ~CGateTransGameServerMsg();

  CGateTransGameServerMsg(const CGateTransGameServerMsg& from);

  inline CGateTransGameServerMsg& operator=(const CGateTransGameServerMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGateTransGameServerMsg& default_instance();

  void Swap(CGateTransGameServerMsg* other);

  // implements Message ----------------------------------------------

  CGateTransGameServerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CGateTransGameServerMsg& from);
  void MergeFrom(const CGateTransGameServerMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_session_id = 1;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional bytes msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CGateTransGameServerMsg)
 private:
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::uint32 client_session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CGateTransGameServerMsg* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerEnterGameReq : public ::google::protobuf::Message {
 public:
  NewPlayerEnterGameReq();
  virtual ~NewPlayerEnterGameReq();

  NewPlayerEnterGameReq(const NewPlayerEnterGameReq& from);

  inline NewPlayerEnterGameReq& operator=(const NewPlayerEnterGameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerEnterGameReq& default_instance();

  void Swap(NewPlayerEnterGameReq* other);

  // implements Message ----------------------------------------------

  NewPlayerEnterGameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerEnterGameReq& from);
  void MergeFrom(const NewPlayerEnterGameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_session_id = 1;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional uint32 remote_ip = 2;
  inline bool has_remote_ip() const;
  inline void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 2;
  inline ::google::protobuf::uint32 remote_ip() const;
  inline void set_remote_ip(::google::protobuf::uint32 value);

  // optional uint32 remote_port = 3;
  inline bool has_remote_port() const;
  inline void clear_remote_port();
  static const int kRemotePortFieldNumber = 3;
  inline ::google::protobuf::uint32 remote_port() const;
  inline void set_remote_port(::google::protobuf::uint32 value);

  // optional string gate_id = 4;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 4;
  inline const ::std::string& gate_id() const;
  inline void set_gate_id(const ::std::string& value);
  inline void set_gate_id(const char* value);
  inline void set_gate_id(const char* value, size_t size);
  inline ::std::string* mutable_gate_id();
  inline ::std::string* release_gate_id();
  inline void set_allocated_gate_id(::std::string* gate_id);

  // optional string account = 5;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 5;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint64 playerid = 6;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 6;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional int32 switch_gs = 7;
  inline bool has_switch_gs() const;
  inline void clear_switch_gs();
  static const int kSwitchGsFieldNumber = 7;
  inline ::google::protobuf::int32 switch_gs() const;
  inline void set_switch_gs(::google::protobuf::int32 value);

  // optional int32 platform_id = 8;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 8;
  inline ::google::protobuf::int32 platform_id() const;
  inline void set_platform_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.NewPlayerEnterGameReq)
 private:
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_remote_ip();
  inline void clear_has_remote_ip();
  inline void set_has_remote_port();
  inline void clear_has_remote_port();
  inline void set_has_gate_id();
  inline void clear_has_gate_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_switch_gs();
  inline void clear_has_switch_gs();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 client_session_id_;
  ::google::protobuf::uint32 remote_ip_;
  ::std::string* gate_id_;
  ::std::string* account_;
  ::google::protobuf::uint32 remote_port_;
  ::google::protobuf::int32 switch_gs_;
  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::int32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static NewPlayerEnterGameReq* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerEnterGameAck : public ::google::protobuf::Message {
 public:
  NewPlayerEnterGameAck();
  virtual ~NewPlayerEnterGameAck();

  NewPlayerEnterGameAck(const NewPlayerEnterGameAck& from);

  inline NewPlayerEnterGameAck& operator=(const NewPlayerEnterGameAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerEnterGameAck& default_instance();

  void Swap(NewPlayerEnterGameAck* other);

  // implements Message ----------------------------------------------

  NewPlayerEnterGameAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerEnterGameAck& from);
  void MergeFrom(const NewPlayerEnterGameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_session_id = 1;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional int32 error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.NewPlayerEnterGameAck)
 private:
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 client_session_id_;
  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static NewPlayerEnterGameAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerTerminateGateRpt : public ::google::protobuf::Message {
 public:
  PlayerTerminateGateRpt();
  virtual ~PlayerTerminateGateRpt();

  PlayerTerminateGateRpt(const PlayerTerminateGateRpt& from);

  inline PlayerTerminateGateRpt& operator=(const PlayerTerminateGateRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerTerminateGateRpt& default_instance();

  void Swap(PlayerTerminateGateRpt* other);

  // implements Message ----------------------------------------------

  PlayerTerminateGateRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerTerminateGateRpt& from);
  void MergeFrom(const PlayerTerminateGateRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_session_id = 1;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.PlayerTerminateGateRpt)
 private:
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 client_session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static PlayerTerminateGateRpt* default_instance_;
};
// -------------------------------------------------------------------

class KickOutPlayerRpt : public ::google::protobuf::Message {
 public:
  KickOutPlayerRpt();
  virtual ~KickOutPlayerRpt();

  KickOutPlayerRpt(const KickOutPlayerRpt& from);

  inline KickOutPlayerRpt& operator=(const KickOutPlayerRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickOutPlayerRpt& default_instance();

  void Swap(KickOutPlayerRpt* other);

  // implements Message ----------------------------------------------

  KickOutPlayerRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickOutPlayerRpt& from);
  void MergeFrom(const KickOutPlayerRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional uint32 session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional int32 error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.KickOutPlayerRpt)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::int32 error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static KickOutPlayerRpt* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckReq : public ::google::protobuf::Message {
 public:
  CRandCheckReq();
  virtual ~CRandCheckReq();

  CRandCheckReq(const CRandCheckReq& from);

  inline CRandCheckReq& operator=(const CRandCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckReq& default_instance();

  void Swap(CRandCheckReq* other);

  // implements Message ----------------------------------------------

  CRandCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckReq& from);
  void MergeFrom(const CRandCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes randkeys = 1;
  inline bool has_randkeys() const;
  inline void clear_randkeys();
  static const int kRandkeysFieldNumber = 1;
  inline const ::std::string& randkeys() const;
  inline void set_randkeys(const ::std::string& value);
  inline void set_randkeys(const char* value);
  inline void set_randkeys(const void* value, size_t size);
  inline ::std::string* mutable_randkeys();
  inline ::std::string* release_randkeys();
  inline void set_allocated_randkeys(::std::string* randkeys);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CRandCheckReq)
 private:
  inline void set_has_randkeys();
  inline void clear_has_randkeys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randkeys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckAck : public ::google::protobuf::Message {
 public:
  CRandCheckAck();
  virtual ~CRandCheckAck();

  CRandCheckAck(const CRandCheckAck& from);

  inline CRandCheckAck& operator=(const CRandCheckAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckAck& default_instance();

  void Swap(CRandCheckAck* other);

  // implements Message ----------------------------------------------

  CRandCheckAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckAck& from);
  void MergeFrom(const CRandCheckAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes keys = 1;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys() const;
  inline void set_keys(const ::std::string& value);
  inline void set_keys(const char* value);
  inline void set_keys(const void* value, size_t size);
  inline ::std::string* mutable_keys();
  inline ::std::string* release_keys();
  inline void set_allocated_keys(::std::string* keys);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CRandCheckAck)
 private:
  inline void set_has_keys();
  inline void clear_has_keys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckAck* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPing : public ::google::protobuf::Message {
 public:
  CHeartPing();
  virtual ~CHeartPing();

  CHeartPing(const CHeartPing& from);

  inline CHeartPing& operator=(const CHeartPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPing& default_instance();

  void Swap(CHeartPing* other);

  // implements Message ----------------------------------------------

  CHeartPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPing& from);
  void MergeFrom(const CHeartPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CHeartPing)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CHeartPing* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPingAck : public ::google::protobuf::Message {
 public:
  CHeartPingAck();
  virtual ~CHeartPingAck();

  CHeartPingAck(const CHeartPingAck& from);

  inline CHeartPingAck& operator=(const CHeartPingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPingAck& default_instance();

  void Swap(CHeartPingAck* other);

  // implements Message ----------------------------------------------

  CHeartPingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPingAck& from);
  void MergeFrom(const CHeartPingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.CHeartPingAck)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static CHeartPingAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSwitchGSReq : public ::google::protobuf::Message {
 public:
  PlayerSwitchGSReq();
  virtual ~PlayerSwitchGSReq();

  PlayerSwitchGSReq(const PlayerSwitchGSReq& from);

  inline PlayerSwitchGSReq& operator=(const PlayerSwitchGSReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSwitchGSReq& default_instance();

  void Swap(PlayerSwitchGSReq* other);

  // implements Message ----------------------------------------------

  PlayerSwitchGSReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSwitchGSReq& from);
  void MergeFrom(const PlayerSwitchGSReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional uint32 client_session_id = 2;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional string gs_id = 3;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 3;
  inline const ::std::string& gs_id() const;
  inline void set_gs_id(const ::std::string& value);
  inline void set_gs_id(const char* value);
  inline void set_gs_id(const char* value, size_t size);
  inline ::std::string* mutable_gs_id();
  inline ::std::string* release_gs_id();
  inline void set_allocated_gs_id(::std::string* gs_id);

  // optional int32 platform_id = 4;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 4;
  inline ::google::protobuf::int32 platform_id() const;
  inline void set_platform_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.PlayerSwitchGSReq)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* gs_id_;
  ::google::protobuf::uint32 client_session_id_;
  ::google::protobuf::int32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static PlayerSwitchGSReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSwitchGSAck : public ::google::protobuf::Message {
 public:
  PlayerSwitchGSAck();
  virtual ~PlayerSwitchGSAck();

  PlayerSwitchGSAck(const PlayerSwitchGSAck& from);

  inline PlayerSwitchGSAck& operator=(const PlayerSwitchGSAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSwitchGSAck& default_instance();

  void Swap(PlayerSwitchGSAck* other);

  // implements Message ----------------------------------------------

  PlayerSwitchGSAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSwitchGSAck& from);
  void MergeFrom(const PlayerSwitchGSAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional uint32 client_session_id = 2;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional string gs_id = 3;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 3;
  inline const ::std::string& gs_id() const;
  inline void set_gs_id(const ::std::string& value);
  inline void set_gs_id(const char* value);
  inline void set_gs_id(const char* value, size_t size);
  inline ::std::string* mutable_gs_id();
  inline ::std::string* release_gs_id();
  inline void set_allocated_gs_id(::std::string* gs_id);

  // optional int32 err_no = 4;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 4;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.PlayerSwitchGSAck)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* gs_id_;
  ::google::protobuf::uint32 client_session_id_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static PlayerSwitchGSAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerReLoginReq : public ::google::protobuf::Message {
 public:
  PlayerReLoginReq();
  virtual ~PlayerReLoginReq();

  PlayerReLoginReq(const PlayerReLoginReq& from);

  inline PlayerReLoginReq& operator=(const PlayerReLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerReLoginReq& default_instance();

  void Swap(PlayerReLoginReq* other);

  // implements Message ----------------------------------------------

  PlayerReLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerReLoginReq& from);
  void MergeFrom(const PlayerReLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional uint32 client_session_id = 2;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional string gs_id = 3;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 3;
  inline const ::std::string& gs_id() const;
  inline void set_gs_id(const ::std::string& value);
  inline void set_gs_id(const char* value);
  inline void set_gs_id(const char* value, size_t size);
  inline ::std::string* mutable_gs_id();
  inline ::std::string* release_gs_id();
  inline void set_allocated_gs_id(::std::string* gs_id);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.PlayerReLoginReq)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* gs_id_;
  ::google::protobuf::uint32 client_session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static PlayerReLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerReLoginAck : public ::google::protobuf::Message {
 public:
  PlayerReLoginAck();
  virtual ~PlayerReLoginAck();

  PlayerReLoginAck(const PlayerReLoginAck& from);

  inline PlayerReLoginAck& operator=(const PlayerReLoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerReLoginAck& default_instance();

  void Swap(PlayerReLoginAck* other);

  // implements Message ----------------------------------------------

  PlayerReLoginAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerReLoginAck& from);
  void MergeFrom(const PlayerReLoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 digit_account = 1;
  inline bool has_digit_account() const;
  inline void clear_digit_account();
  static const int kDigitAccountFieldNumber = 1;
  inline ::google::protobuf::uint64 digit_account() const;
  inline void set_digit_account(::google::protobuf::uint64 value);

  // optional uint32 client_session_id = 2;
  inline bool has_client_session_id() const;
  inline void clear_client_session_id();
  static const int kClientSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 client_session_id() const;
  inline void set_client_session_id(::google::protobuf::uint32 value);

  // optional string gs_id = 3;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 3;
  inline const ::std::string& gs_id() const;
  inline void set_gs_id(const ::std::string& value);
  inline void set_gs_id(const char* value);
  inline void set_gs_id(const char* value, size_t size);
  inline ::std::string* mutable_gs_id();
  inline ::std::string* release_gs_id();
  inline void set_allocated_gs_id(::std::string* gs_id);

  // optional int32 err_no = 4;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 4;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.PlayerReLoginAck)
 private:
  inline void set_has_digit_account();
  inline void clear_has_digit_account();
  inline void set_has_client_session_id();
  inline void clear_has_client_session_id();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 digit_account_;
  ::std::string* gs_id_;
  ::google::protobuf::uint32 client_session_id_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static PlayerReLoginAck* default_instance_;
};
// -------------------------------------------------------------------

class GateCloseNtf : public ::google::protobuf::Message {
 public:
  GateCloseNtf();
  virtual ~GateCloseNtf();

  GateCloseNtf(const GateCloseNtf& from);

  inline GateCloseNtf& operator=(const GateCloseNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GateCloseNtf& default_instance();

  void Swap(GateCloseNtf* other);

  // implements Message ----------------------------------------------

  GateCloseNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GateCloseNtf& from);
  void MergeFrom(const GateCloseNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.GateCloseNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static GateCloseNtf* default_instance_;
};
// -------------------------------------------------------------------

class login_gt_req : public ::google::protobuf::Message {
 public:
  login_gt_req();
  virtual ~login_gt_req();

  login_gt_req(const login_gt_req& from);

  inline login_gt_req& operator=(const login_gt_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_gt_req& default_instance();

  void Swap(login_gt_req* other);

  // implements Message ----------------------------------------------

  login_gt_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_gt_req& from);
  void MergeFrom(const login_gt_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 old_sessionid = 3;
  inline bool has_old_sessionid() const;
  inline void clear_old_sessionid();
  static const int kOldSessionidFieldNumber = 3;
  inline ::google::protobuf::uint32 old_sessionid() const;
  inline void set_old_sessionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.login_gt_req)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_old_sessionid();
  inline void clear_has_old_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* account_;
  ::google::protobuf::uint32 old_sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static login_gt_req* default_instance_;
};
// -------------------------------------------------------------------

class login_gt_ack : public ::google::protobuf::Message {
 public:
  login_gt_ack();
  virtual ~login_gt_ack();

  login_gt_ack(const login_gt_ack& from);

  inline login_gt_ack& operator=(const login_gt_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_gt_ack& default_instance();

  void Swap(login_gt_ack* other);

  // implements Message ----------------------------------------------

  login_gt_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_gt_ack& from);
  void MergeFrom(const login_gt_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string gate_ip = 2;
  inline bool has_gate_ip() const;
  inline void clear_gate_ip();
  static const int kGateIpFieldNumber = 2;
  inline const ::std::string& gate_ip() const;
  inline void set_gate_ip(const ::std::string& value);
  inline void set_gate_ip(const char* value);
  inline void set_gate_ip(const char* value, size_t size);
  inline ::std::string* mutable_gate_ip();
  inline ::std::string* release_gate_ip();
  inline void set_allocated_gate_ip(::std::string* gate_ip);

  // optional int32 gateport = 3;
  inline bool has_gateport() const;
  inline void clear_gateport();
  static const int kGateportFieldNumber = 3;
  inline ::google::protobuf::int32 gateport() const;
  inline void set_gateport(::google::protobuf::int32 value);

  // optional int32 gate_key = 4;
  inline bool has_gate_key() const;
  inline void clear_gate_key();
  static const int kGateKeyFieldNumber = 4;
  inline ::google::protobuf::int32 gate_key() const;
  inline void set_gate_key(::google::protobuf::int32 value);

  // optional int32 err_no = 5;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 5;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.login_gt_ack)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gate_ip();
  inline void clear_has_gate_ip();
  inline void set_has_gateport();
  inline void clear_has_gateport();
  inline void set_has_gate_key();
  inline void clear_has_gate_key();
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* gate_ip_;
  ::google::protobuf::int32 gateport_;
  ::google::protobuf::int32 gate_key_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static login_gt_ack* default_instance_;
};
// -------------------------------------------------------------------

class client_number_rpt : public ::google::protobuf::Message {
 public:
  client_number_rpt();
  virtual ~client_number_rpt();

  client_number_rpt(const client_number_rpt& from);

  inline client_number_rpt& operator=(const client_number_rpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_number_rpt& default_instance();

  void Swap(client_number_rpt* other);

  // implements Message ----------------------------------------------

  client_number_rpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_number_rpt& from);
  void MergeFrom(const client_number_rpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional string gate_id = 2;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 2;
  inline const ::std::string& gate_id() const;
  inline void set_gate_id(const ::std::string& value);
  inline void set_gate_id(const char* value);
  inline void set_gate_id(const char* value, size_t size);
  inline ::std::string* mutable_gate_id();
  inline ::std::string* release_gate_id();
  inline void set_allocated_gate_id(::std::string* gate_id);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.client_number_rpt)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_gate_id();
  inline void clear_has_gate_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gate_id_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static client_number_rpt* default_instance_;
};
// -------------------------------------------------------------------

class client_login_gate_time_out_rpt : public ::google::protobuf::Message {
 public:
  client_login_gate_time_out_rpt();
  virtual ~client_login_gate_time_out_rpt();

  client_login_gate_time_out_rpt(const client_login_gate_time_out_rpt& from);

  inline client_login_gate_time_out_rpt& operator=(const client_login_gate_time_out_rpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_login_gate_time_out_rpt& default_instance();

  void Swap(client_login_gate_time_out_rpt* other);

  // implements Message ----------------------------------------------

  client_login_gate_time_out_rpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_login_gate_time_out_rpt& from);
  void MergeFrom(const client_login_gate_time_out_rpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.gameserver_gate.client_login_gate_time_out_rpt)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameserver_5fgate_2eproto();
  friend void protobuf_AssignDesc_gameserver_5fgate_2eproto();
  friend void protobuf_ShutdownFile_gameserver_5fgate_2eproto();

  void InitAsDefaultInstance();
  static client_login_gate_time_out_rpt* default_instance_;
};
// ===================================================================


// ===================================================================

// CGameServerReport

// optional string id = 1;
inline bool CGameServerReport::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGameServerReport::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGameServerReport::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGameServerReport::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CGameServerReport::id() const {
  return *id_;
}
inline void CGameServerReport::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGameServerReport::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGameServerReport::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGameServerReport::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CGameServerReport::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGameServerReport::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CGameServerReport::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGameServerReport::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGameServerReport::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGameServerReport::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CGameServerReport::name() const {
  return *name_;
}
inline void CGameServerReport::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGameServerReport::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGameServerReport::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGameServerReport::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CGameServerReport::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGameServerReport::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 online_number = 3;
inline bool CGameServerReport::has_online_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CGameServerReport::set_has_online_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CGameServerReport::clear_has_online_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CGameServerReport::clear_online_number() {
  online_number_ = 0;
  clear_has_online_number();
}
inline ::google::protobuf::int32 CGameServerReport::online_number() const {
  return online_number_;
}
inline void CGameServerReport::set_online_number(::google::protobuf::int32 value) {
  set_has_online_number();
  online_number_ = value;
}

// -------------------------------------------------------------------

// CGateServerReport

// optional string id = 1;
inline bool CGateServerReport::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGateServerReport::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGateServerReport::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGateServerReport::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CGateServerReport::id() const {
  return *id_;
}
inline void CGateServerReport::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGateServerReport::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CGateServerReport::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGateServerReport::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CGateServerReport::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGateServerReport::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CGateServerReport::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGateServerReport::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGateServerReport::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGateServerReport::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CGateServerReport::name() const {
  return *name_;
}
inline void CGateServerReport::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGateServerReport::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CGateServerReport::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGateServerReport::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CGateServerReport::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGateServerReport::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGateTransClientMsg

// optional uint32 client_session_id = 1;
inline bool CGateTransClientMsg::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGateTransClientMsg::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGateTransClientMsg::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGateTransClientMsg::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 CGateTransClientMsg::client_session_id() const {
  return client_session_id_;
}
inline void CGateTransClientMsg::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional bytes msg = 2;
inline bool CGateTransClientMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGateTransClientMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGateTransClientMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGateTransClientMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& CGateTransClientMsg::msg() const {
  return *msg_;
}
inline void CGateTransClientMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CGateTransClientMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CGateTransClientMsg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGateTransClientMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* CGateTransClientMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGateTransClientMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CGateTransGameServerMsg

// optional uint32 client_session_id = 1;
inline bool CGateTransGameServerMsg::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGateTransGameServerMsg::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGateTransGameServerMsg::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGateTransGameServerMsg::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 CGateTransGameServerMsg::client_session_id() const {
  return client_session_id_;
}
inline void CGateTransGameServerMsg::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional bytes msg = 2;
inline bool CGateTransGameServerMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGateTransGameServerMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGateTransGameServerMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGateTransGameServerMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& CGateTransGameServerMsg::msg() const {
  return *msg_;
}
inline void CGateTransGameServerMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CGateTransGameServerMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CGateTransGameServerMsg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CGateTransGameServerMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* CGateTransGameServerMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CGateTransGameServerMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NewPlayerEnterGameReq

// optional uint32 client_session_id = 1;
inline bool NewPlayerEnterGameReq::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewPlayerEnterGameReq::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewPlayerEnterGameReq::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 NewPlayerEnterGameReq::client_session_id() const {
  return client_session_id_;
}
inline void NewPlayerEnterGameReq::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional uint32 remote_ip = 2;
inline bool NewPlayerEnterGameReq::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewPlayerEnterGameReq::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewPlayerEnterGameReq::clear_remote_ip() {
  remote_ip_ = 0u;
  clear_has_remote_ip();
}
inline ::google::protobuf::uint32 NewPlayerEnterGameReq::remote_ip() const {
  return remote_ip_;
}
inline void NewPlayerEnterGameReq::set_remote_ip(::google::protobuf::uint32 value) {
  set_has_remote_ip();
  remote_ip_ = value;
}

// optional uint32 remote_port = 3;
inline bool NewPlayerEnterGameReq::has_remote_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_remote_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewPlayerEnterGameReq::clear_has_remote_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewPlayerEnterGameReq::clear_remote_port() {
  remote_port_ = 0u;
  clear_has_remote_port();
}
inline ::google::protobuf::uint32 NewPlayerEnterGameReq::remote_port() const {
  return remote_port_;
}
inline void NewPlayerEnterGameReq::set_remote_port(::google::protobuf::uint32 value) {
  set_has_remote_port();
  remote_port_ = value;
}

// optional string gate_id = 4;
inline bool NewPlayerEnterGameReq::has_gate_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_gate_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewPlayerEnterGameReq::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewPlayerEnterGameReq::clear_gate_id() {
  if (gate_id_ != &::google::protobuf::internal::kEmptyString) {
    gate_id_->clear();
  }
  clear_has_gate_id();
}
inline const ::std::string& NewPlayerEnterGameReq::gate_id() const {
  return *gate_id_;
}
inline void NewPlayerEnterGameReq::set_gate_id(const ::std::string& value) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(value);
}
inline void NewPlayerEnterGameReq::set_gate_id(const char* value) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(value);
}
inline void NewPlayerEnterGameReq::set_gate_id(const char* value, size_t size) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewPlayerEnterGameReq::mutable_gate_id() {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  return gate_id_;
}
inline ::std::string* NewPlayerEnterGameReq::release_gate_id() {
  clear_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_id_;
    gate_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewPlayerEnterGameReq::set_allocated_gate_id(::std::string* gate_id) {
  if (gate_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_id_;
  }
  if (gate_id) {
    set_has_gate_id();
    gate_id_ = gate_id;
  } else {
    clear_has_gate_id();
    gate_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 5;
inline bool NewPlayerEnterGameReq::has_account() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_account() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewPlayerEnterGameReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewPlayerEnterGameReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& NewPlayerEnterGameReq::account() const {
  return *account_;
}
inline void NewPlayerEnterGameReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NewPlayerEnterGameReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NewPlayerEnterGameReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewPlayerEnterGameReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* NewPlayerEnterGameReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewPlayerEnterGameReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 playerid = 6;
inline bool NewPlayerEnterGameReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewPlayerEnterGameReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewPlayerEnterGameReq::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 NewPlayerEnterGameReq::playerid() const {
  return playerid_;
}
inline void NewPlayerEnterGameReq::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional int32 switch_gs = 7;
inline bool NewPlayerEnterGameReq::has_switch_gs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_switch_gs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewPlayerEnterGameReq::clear_has_switch_gs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewPlayerEnterGameReq::clear_switch_gs() {
  switch_gs_ = 0;
  clear_has_switch_gs();
}
inline ::google::protobuf::int32 NewPlayerEnterGameReq::switch_gs() const {
  return switch_gs_;
}
inline void NewPlayerEnterGameReq::set_switch_gs(::google::protobuf::int32 value) {
  set_has_switch_gs();
  switch_gs_ = value;
}

// optional int32 platform_id = 8;
inline bool NewPlayerEnterGameReq::has_platform_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewPlayerEnterGameReq::set_has_platform_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewPlayerEnterGameReq::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewPlayerEnterGameReq::clear_platform_id() {
  platform_id_ = 0;
  clear_has_platform_id();
}
inline ::google::protobuf::int32 NewPlayerEnterGameReq::platform_id() const {
  return platform_id_;
}
inline void NewPlayerEnterGameReq::set_platform_id(::google::protobuf::int32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// NewPlayerEnterGameAck

// optional uint32 client_session_id = 1;
inline bool NewPlayerEnterGameAck::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewPlayerEnterGameAck::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewPlayerEnterGameAck::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewPlayerEnterGameAck::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 NewPlayerEnterGameAck::client_session_id() const {
  return client_session_id_;
}
inline void NewPlayerEnterGameAck::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional int32 error_code = 2;
inline bool NewPlayerEnterGameAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewPlayerEnterGameAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewPlayerEnterGameAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewPlayerEnterGameAck::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 NewPlayerEnterGameAck::error_code() const {
  return error_code_;
}
inline void NewPlayerEnterGameAck::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// PlayerTerminateGateRpt

// optional uint32 client_session_id = 1;
inline bool PlayerTerminateGateRpt::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerTerminateGateRpt::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerTerminateGateRpt::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerTerminateGateRpt::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 PlayerTerminateGateRpt::client_session_id() const {
  return client_session_id_;
}
inline void PlayerTerminateGateRpt::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// -------------------------------------------------------------------

// KickOutPlayerRpt

// optional uint64 digit_account = 1;
inline bool KickOutPlayerRpt::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickOutPlayerRpt::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickOutPlayerRpt::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickOutPlayerRpt::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 KickOutPlayerRpt::digit_account() const {
  return digit_account_;
}
inline void KickOutPlayerRpt::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional uint32 session_id = 2;
inline bool KickOutPlayerRpt::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickOutPlayerRpt::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickOutPlayerRpt::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickOutPlayerRpt::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 KickOutPlayerRpt::session_id() const {
  return session_id_;
}
inline void KickOutPlayerRpt::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional int32 error_code = 3;
inline bool KickOutPlayerRpt::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickOutPlayerRpt::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickOutPlayerRpt::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickOutPlayerRpt::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 KickOutPlayerRpt::error_code() const {
  return error_code_;
}
inline void KickOutPlayerRpt::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// CRandCheckReq

// optional bytes randkeys = 1;
inline bool CRandCheckReq::has_randkeys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckReq::set_has_randkeys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckReq::clear_has_randkeys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckReq::clear_randkeys() {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    randkeys_->clear();
  }
  clear_has_randkeys();
}
inline const ::std::string& CRandCheckReq::randkeys() const {
  return *randkeys_;
}
inline void CRandCheckReq::set_randkeys(const ::std::string& value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const char* value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const void* value, size_t size) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckReq::mutable_randkeys() {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  return randkeys_;
}
inline ::std::string* CRandCheckReq::release_randkeys() {
  clear_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randkeys_;
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckReq::set_allocated_randkeys(::std::string* randkeys) {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    delete randkeys_;
  }
  if (randkeys) {
    set_has_randkeys();
    randkeys_ = randkeys;
  } else {
    clear_has_randkeys();
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRandCheckAck

// optional bytes keys = 1;
inline bool CRandCheckAck::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckAck::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckAck::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckAck::clear_keys() {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    keys_->clear();
  }
  clear_has_keys();
}
inline const ::std::string& CRandCheckAck::keys() const {
  return *keys_;
}
inline void CRandCheckAck::set_keys(const ::std::string& value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const char* value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const void* value, size_t size) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckAck::mutable_keys() {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  return keys_;
}
inline ::std::string* CRandCheckAck::release_keys() {
  clear_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keys_;
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckAck::set_allocated_keys(::std::string* keys) {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    delete keys_;
  }
  if (keys) {
    set_has_keys();
    keys_ = keys;
  } else {
    clear_has_keys();
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CHeartPing

// optional int32 opt = 1;
inline bool CHeartPing::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPing::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPing::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPing::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPing::opt() const {
  return opt_;
}
inline void CHeartPing::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// CHeartPingAck

// optional int32 opt = 1;
inline bool CHeartPingAck::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPingAck::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPingAck::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPingAck::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPingAck::opt() const {
  return opt_;
}
inline void CHeartPingAck::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// PlayerSwitchGSReq

// optional uint64 digit_account = 1;
inline bool PlayerSwitchGSReq::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSwitchGSReq::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSwitchGSReq::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSwitchGSReq::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 PlayerSwitchGSReq::digit_account() const {
  return digit_account_;
}
inline void PlayerSwitchGSReq::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional uint32 client_session_id = 2;
inline bool PlayerSwitchGSReq::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSwitchGSReq::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSwitchGSReq::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSwitchGSReq::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 PlayerSwitchGSReq::client_session_id() const {
  return client_session_id_;
}
inline void PlayerSwitchGSReq::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional string gs_id = 3;
inline bool PlayerSwitchGSReq::has_gs_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSwitchGSReq::set_has_gs_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSwitchGSReq::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSwitchGSReq::clear_gs_id() {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    gs_id_->clear();
  }
  clear_has_gs_id();
}
inline const ::std::string& PlayerSwitchGSReq::gs_id() const {
  return *gs_id_;
}
inline void PlayerSwitchGSReq::set_gs_id(const ::std::string& value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerSwitchGSReq::set_gs_id(const char* value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerSwitchGSReq::set_gs_id(const char* value, size_t size) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerSwitchGSReq::mutable_gs_id() {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  return gs_id_;
}
inline ::std::string* PlayerSwitchGSReq::release_gs_id() {
  clear_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gs_id_;
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerSwitchGSReq::set_allocated_gs_id(::std::string* gs_id) {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gs_id_;
  }
  if (gs_id) {
    set_has_gs_id();
    gs_id_ = gs_id;
  } else {
    clear_has_gs_id();
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 platform_id = 4;
inline bool PlayerSwitchGSReq::has_platform_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerSwitchGSReq::set_has_platform_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerSwitchGSReq::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerSwitchGSReq::clear_platform_id() {
  platform_id_ = 0;
  clear_has_platform_id();
}
inline ::google::protobuf::int32 PlayerSwitchGSReq::platform_id() const {
  return platform_id_;
}
inline void PlayerSwitchGSReq::set_platform_id(::google::protobuf::int32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// PlayerSwitchGSAck

// optional uint64 digit_account = 1;
inline bool PlayerSwitchGSAck::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSwitchGSAck::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSwitchGSAck::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSwitchGSAck::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 PlayerSwitchGSAck::digit_account() const {
  return digit_account_;
}
inline void PlayerSwitchGSAck::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional uint32 client_session_id = 2;
inline bool PlayerSwitchGSAck::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSwitchGSAck::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSwitchGSAck::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSwitchGSAck::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 PlayerSwitchGSAck::client_session_id() const {
  return client_session_id_;
}
inline void PlayerSwitchGSAck::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional string gs_id = 3;
inline bool PlayerSwitchGSAck::has_gs_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSwitchGSAck::set_has_gs_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSwitchGSAck::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSwitchGSAck::clear_gs_id() {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    gs_id_->clear();
  }
  clear_has_gs_id();
}
inline const ::std::string& PlayerSwitchGSAck::gs_id() const {
  return *gs_id_;
}
inline void PlayerSwitchGSAck::set_gs_id(const ::std::string& value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerSwitchGSAck::set_gs_id(const char* value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerSwitchGSAck::set_gs_id(const char* value, size_t size) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerSwitchGSAck::mutable_gs_id() {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  return gs_id_;
}
inline ::std::string* PlayerSwitchGSAck::release_gs_id() {
  clear_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gs_id_;
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerSwitchGSAck::set_allocated_gs_id(::std::string* gs_id) {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gs_id_;
  }
  if (gs_id) {
    set_has_gs_id();
    gs_id_ = gs_id;
  } else {
    clear_has_gs_id();
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 err_no = 4;
inline bool PlayerSwitchGSAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerSwitchGSAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerSwitchGSAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerSwitchGSAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 PlayerSwitchGSAck::err_no() const {
  return err_no_;
}
inline void PlayerSwitchGSAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// PlayerReLoginReq

// optional uint64 digit_account = 1;
inline bool PlayerReLoginReq::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerReLoginReq::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerReLoginReq::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerReLoginReq::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 PlayerReLoginReq::digit_account() const {
  return digit_account_;
}
inline void PlayerReLoginReq::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional uint32 client_session_id = 2;
inline bool PlayerReLoginReq::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerReLoginReq::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerReLoginReq::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerReLoginReq::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 PlayerReLoginReq::client_session_id() const {
  return client_session_id_;
}
inline void PlayerReLoginReq::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional string gs_id = 3;
inline bool PlayerReLoginReq::has_gs_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerReLoginReq::set_has_gs_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerReLoginReq::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerReLoginReq::clear_gs_id() {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    gs_id_->clear();
  }
  clear_has_gs_id();
}
inline const ::std::string& PlayerReLoginReq::gs_id() const {
  return *gs_id_;
}
inline void PlayerReLoginReq::set_gs_id(const ::std::string& value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerReLoginReq::set_gs_id(const char* value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerReLoginReq::set_gs_id(const char* value, size_t size) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerReLoginReq::mutable_gs_id() {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  return gs_id_;
}
inline ::std::string* PlayerReLoginReq::release_gs_id() {
  clear_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gs_id_;
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerReLoginReq::set_allocated_gs_id(::std::string* gs_id) {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gs_id_;
  }
  if (gs_id) {
    set_has_gs_id();
    gs_id_ = gs_id;
  } else {
    clear_has_gs_id();
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerReLoginAck

// optional uint64 digit_account = 1;
inline bool PlayerReLoginAck::has_digit_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerReLoginAck::set_has_digit_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerReLoginAck::clear_has_digit_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerReLoginAck::clear_digit_account() {
  digit_account_ = GOOGLE_ULONGLONG(0);
  clear_has_digit_account();
}
inline ::google::protobuf::uint64 PlayerReLoginAck::digit_account() const {
  return digit_account_;
}
inline void PlayerReLoginAck::set_digit_account(::google::protobuf::uint64 value) {
  set_has_digit_account();
  digit_account_ = value;
}

// optional uint32 client_session_id = 2;
inline bool PlayerReLoginAck::has_client_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerReLoginAck::set_has_client_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerReLoginAck::clear_has_client_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerReLoginAck::clear_client_session_id() {
  client_session_id_ = 0u;
  clear_has_client_session_id();
}
inline ::google::protobuf::uint32 PlayerReLoginAck::client_session_id() const {
  return client_session_id_;
}
inline void PlayerReLoginAck::set_client_session_id(::google::protobuf::uint32 value) {
  set_has_client_session_id();
  client_session_id_ = value;
}

// optional string gs_id = 3;
inline bool PlayerReLoginAck::has_gs_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerReLoginAck::set_has_gs_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerReLoginAck::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerReLoginAck::clear_gs_id() {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    gs_id_->clear();
  }
  clear_has_gs_id();
}
inline const ::std::string& PlayerReLoginAck::gs_id() const {
  return *gs_id_;
}
inline void PlayerReLoginAck::set_gs_id(const ::std::string& value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerReLoginAck::set_gs_id(const char* value) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(value);
}
inline void PlayerReLoginAck::set_gs_id(const char* value, size_t size) {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  gs_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerReLoginAck::mutable_gs_id() {
  set_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    gs_id_ = new ::std::string;
  }
  return gs_id_;
}
inline ::std::string* PlayerReLoginAck::release_gs_id() {
  clear_has_gs_id();
  if (gs_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gs_id_;
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerReLoginAck::set_allocated_gs_id(::std::string* gs_id) {
  if (gs_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gs_id_;
  }
  if (gs_id) {
    set_has_gs_id();
    gs_id_ = gs_id;
  } else {
    clear_has_gs_id();
    gs_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 err_no = 4;
inline bool PlayerReLoginAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerReLoginAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerReLoginAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerReLoginAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 PlayerReLoginAck::err_no() const {
  return err_no_;
}
inline void PlayerReLoginAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// GateCloseNtf

// -------------------------------------------------------------------

// login_gt_req

// optional uint64 playerid = 1;
inline bool login_gt_req::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_gt_req::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_gt_req::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_gt_req::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 login_gt_req::playerid() const {
  return playerid_;
}
inline void login_gt_req::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string account = 2;
inline bool login_gt_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_gt_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_gt_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_gt_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& login_gt_req::account() const {
  return *account_;
}
inline void login_gt_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void login_gt_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void login_gt_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login_gt_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* login_gt_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login_gt_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 old_sessionid = 3;
inline bool login_gt_req::has_old_sessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login_gt_req::set_has_old_sessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login_gt_req::clear_has_old_sessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login_gt_req::clear_old_sessionid() {
  old_sessionid_ = 0u;
  clear_has_old_sessionid();
}
inline ::google::protobuf::uint32 login_gt_req::old_sessionid() const {
  return old_sessionid_;
}
inline void login_gt_req::set_old_sessionid(::google::protobuf::uint32 value) {
  set_has_old_sessionid();
  old_sessionid_ = value;
}

// -------------------------------------------------------------------

// login_gt_ack

// optional uint64 playerid = 1;
inline bool login_gt_ack::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_gt_ack::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_gt_ack::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_gt_ack::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 login_gt_ack::playerid() const {
  return playerid_;
}
inline void login_gt_ack::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string gate_ip = 2;
inline bool login_gt_ack::has_gate_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login_gt_ack::set_has_gate_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login_gt_ack::clear_has_gate_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login_gt_ack::clear_gate_ip() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    gate_ip_->clear();
  }
  clear_has_gate_ip();
}
inline const ::std::string& login_gt_ack::gate_ip() const {
  return *gate_ip_;
}
inline void login_gt_ack::set_gate_ip(const ::std::string& value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void login_gt_ack::set_gate_ip(const char* value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void login_gt_ack::set_gate_ip(const char* value, size_t size) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* login_gt_ack::mutable_gate_ip() {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  return gate_ip_;
}
inline ::std::string* login_gt_ack::release_gate_ip() {
  clear_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_ip_;
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void login_gt_ack::set_allocated_gate_ip(::std::string* gate_ip) {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  if (gate_ip) {
    set_has_gate_ip();
    gate_ip_ = gate_ip;
  } else {
    clear_has_gate_ip();
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gateport = 3;
inline bool login_gt_ack::has_gateport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login_gt_ack::set_has_gateport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login_gt_ack::clear_has_gateport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login_gt_ack::clear_gateport() {
  gateport_ = 0;
  clear_has_gateport();
}
inline ::google::protobuf::int32 login_gt_ack::gateport() const {
  return gateport_;
}
inline void login_gt_ack::set_gateport(::google::protobuf::int32 value) {
  set_has_gateport();
  gateport_ = value;
}

// optional int32 gate_key = 4;
inline bool login_gt_ack::has_gate_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void login_gt_ack::set_has_gate_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void login_gt_ack::clear_has_gate_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void login_gt_ack::clear_gate_key() {
  gate_key_ = 0;
  clear_has_gate_key();
}
inline ::google::protobuf::int32 login_gt_ack::gate_key() const {
  return gate_key_;
}
inline void login_gt_ack::set_gate_key(::google::protobuf::int32 value) {
  set_has_gate_key();
  gate_key_ = value;
}

// optional int32 err_no = 5;
inline bool login_gt_ack::has_err_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void login_gt_ack::set_has_err_no() {
  _has_bits_[0] |= 0x00000010u;
}
inline void login_gt_ack::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void login_gt_ack::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 login_gt_ack::err_no() const {
  return err_no_;
}
inline void login_gt_ack::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// client_number_rpt

// optional uint32 number = 1;
inline bool client_number_rpt::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_number_rpt::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_number_rpt::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_number_rpt::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 client_number_rpt::number() const {
  return number_;
}
inline void client_number_rpt::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional string gate_id = 2;
inline bool client_number_rpt::has_gate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_number_rpt::set_has_gate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_number_rpt::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_number_rpt::clear_gate_id() {
  if (gate_id_ != &::google::protobuf::internal::kEmptyString) {
    gate_id_->clear();
  }
  clear_has_gate_id();
}
inline const ::std::string& client_number_rpt::gate_id() const {
  return *gate_id_;
}
inline void client_number_rpt::set_gate_id(const ::std::string& value) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(value);
}
inline void client_number_rpt::set_gate_id(const char* value) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(value);
}
inline void client_number_rpt::set_gate_id(const char* value, size_t size) {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  gate_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* client_number_rpt::mutable_gate_id() {
  set_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    gate_id_ = new ::std::string;
  }
  return gate_id_;
}
inline ::std::string* client_number_rpt::release_gate_id() {
  clear_has_gate_id();
  if (gate_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_id_;
    gate_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void client_number_rpt::set_allocated_gate_id(::std::string* gate_id) {
  if (gate_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_id_;
  }
  if (gate_id) {
    set_has_gate_id();
    gate_id_ = gate_id;
  } else {
    clear_has_gate_id();
    gate_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// client_login_gate_time_out_rpt

// optional uint64 playerid = 1;
inline bool client_login_gate_time_out_rpt::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_login_gate_time_out_rpt::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_login_gate_time_out_rpt::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_login_gate_time_out_rpt::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 client_login_gate_time_out_rpt::playerid() const {
  return playerid_;
}
inline void client_login_gate_time_out_rpt::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gameserver_gate
}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameserver_5fgate_2eproto__INCLUDED
