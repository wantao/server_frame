// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.dbserver.proto

#ifndef PROTOBUF_login_2edbserver_2eproto__INCLUDED
#define PROTOBUF_login_2edbserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protoc {
namespace logindbs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login_2edbserver_2eproto();
void protobuf_AssignDesc_login_2edbserver_2eproto();
void protobuf_ShutdownFile_login_2edbserver_2eproto();

class CLoginServerRpt;
class CUserCheckInDBServerReq;
class CUserCheckInDBServerAck;
class CRandCheckReq;
class CRandCheckAck;
class CHeartPing;
class CHeartPingAck;
class GMListRpt;
class GMListRpt_gm;
class AreaMaxOnlineNumberRpt;
class CDBServerRpt;
class LDGetGM_ListReq;
class LDGetGM_ListAck;
class LoginServerCloseNtf;
class PlayerGetBaseDataComplete;
class ClientCloseWhenWaitCheckInDB;
class get_login_key_req;
class get_login_key_ack;
class UpdateFastAttackBlackAccountRpt;

// ===================================================================

class CLoginServerRpt : public ::google::protobuf::Message {
 public:
  CLoginServerRpt();
  virtual ~CLoginServerRpt();

  CLoginServerRpt(const CLoginServerRpt& from);

  inline CLoginServerRpt& operator=(const CLoginServerRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLoginServerRpt& default_instance();

  void Swap(CLoginServerRpt* other);

  // implements Message ----------------------------------------------

  CLoginServerRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CLoginServerRpt& from);
  void MergeFrom(const CLoginServerRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CLoginServerRpt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CLoginServerRpt* default_instance_;
};
// -------------------------------------------------------------------

class CUserCheckInDBServerReq : public ::google::protobuf::Message {
 public:
  CUserCheckInDBServerReq();
  virtual ~CUserCheckInDBServerReq();

  CUserCheckInDBServerReq(const CUserCheckInDBServerReq& from);

  inline CUserCheckInDBServerReq& operator=(const CUserCheckInDBServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserCheckInDBServerReq& default_instance();

  void Swap(CUserCheckInDBServerReq* other);

  // implements Message ----------------------------------------------

  CUserCheckInDBServerReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CUserCheckInDBServerReq& from);
  void MergeFrom(const CUserCheckInDBServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 transID = 1;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransIDFieldNumber = 1;
  inline ::google::protobuf::uint32 transid() const;
  inline void set_transid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 2;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 area_id = 4;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 4;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);

  // optional int32 platform_id = 5;
  inline bool has_platform_id() const;
  inline void clear_platform_id();
  static const int kPlatformIdFieldNumber = 5;
  inline ::google::protobuf::int32 platform_id() const;
  inline void set_platform_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CUserCheckInDBServerReq)
 private:
  inline void set_has_transid();
  inline void clear_has_transid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_platform_id();
  inline void clear_has_platform_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::uint32 transid_;
  ::google::protobuf::int32 area_id_;
  ::std::string* account_;
  ::google::protobuf::int32 platform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CUserCheckInDBServerReq* default_instance_;
};
// -------------------------------------------------------------------

class CUserCheckInDBServerAck : public ::google::protobuf::Message {
 public:
  CUserCheckInDBServerAck();
  virtual ~CUserCheckInDBServerAck();

  CUserCheckInDBServerAck(const CUserCheckInDBServerAck& from);

  inline CUserCheckInDBServerAck& operator=(const CUserCheckInDBServerAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CUserCheckInDBServerAck& default_instance();

  void Swap(CUserCheckInDBServerAck* other);

  // implements Message ----------------------------------------------

  CUserCheckInDBServerAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CUserCheckInDBServerAck& from);
  void MergeFrom(const CUserCheckInDBServerAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 transID = 1;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransIDFieldNumber = 1;
  inline ::google::protobuf::uint32 transid() const;
  inline void set_transid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 2;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional int32 err_no = 3;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 3;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string gate_ip = 4;
  inline bool has_gate_ip() const;
  inline void clear_gate_ip();
  static const int kGateIpFieldNumber = 4;
  inline const ::std::string& gate_ip() const;
  inline void set_gate_ip(const ::std::string& value);
  inline void set_gate_ip(const char* value);
  inline void set_gate_ip(const char* value, size_t size);
  inline ::std::string* mutable_gate_ip();
  inline ::std::string* release_gate_ip();
  inline void set_allocated_gate_ip(::std::string* gate_ip);

  // optional uint32 gate_port = 5;
  inline bool has_gate_port() const;
  inline void clear_gate_port();
  static const int kGatePortFieldNumber = 5;
  inline ::google::protobuf::uint32 gate_port() const;
  inline void set_gate_port(::google::protobuf::uint32 value);

  // optional int32 gate_key = 6;
  inline bool has_gate_key() const;
  inline void clear_gate_key();
  static const int kGateKeyFieldNumber = 6;
  inline ::google::protobuf::int32 gate_key() const;
  inline void set_gate_key(::google::protobuf::int32 value);

  // optional uint32 sessionid = 7;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 7;
  inline ::google::protobuf::uint32 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CUserCheckInDBServerAck)
 private:
  inline void set_has_transid();
  inline void clear_has_transid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_gate_ip();
  inline void clear_has_gate_ip();
  inline void set_has_gate_port();
  inline void clear_has_gate_port();
  inline void set_has_gate_key();
  inline void clear_has_gate_key();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::uint32 transid_;
  ::google::protobuf::int32 err_no_;
  ::std::string* gate_ip_;
  ::google::protobuf::uint32 gate_port_;
  ::google::protobuf::int32 gate_key_;
  ::google::protobuf::uint32 sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CUserCheckInDBServerAck* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckReq : public ::google::protobuf::Message {
 public:
  CRandCheckReq();
  virtual ~CRandCheckReq();

  CRandCheckReq(const CRandCheckReq& from);

  inline CRandCheckReq& operator=(const CRandCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckReq& default_instance();

  void Swap(CRandCheckReq* other);

  // implements Message ----------------------------------------------

  CRandCheckReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckReq& from);
  void MergeFrom(const CRandCheckReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes randkeys = 1;
  inline bool has_randkeys() const;
  inline void clear_randkeys();
  static const int kRandkeysFieldNumber = 1;
  inline const ::std::string& randkeys() const;
  inline void set_randkeys(const ::std::string& value);
  inline void set_randkeys(const char* value);
  inline void set_randkeys(const void* value, size_t size);
  inline ::std::string* mutable_randkeys();
  inline ::std::string* release_randkeys();
  inline void set_allocated_randkeys(::std::string* randkeys);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CRandCheckReq)
 private:
  inline void set_has_randkeys();
  inline void clear_has_randkeys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randkeys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class CRandCheckAck : public ::google::protobuf::Message {
 public:
  CRandCheckAck();
  virtual ~CRandCheckAck();

  CRandCheckAck(const CRandCheckAck& from);

  inline CRandCheckAck& operator=(const CRandCheckAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRandCheckAck& default_instance();

  void Swap(CRandCheckAck* other);

  // implements Message ----------------------------------------------

  CRandCheckAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRandCheckAck& from);
  void MergeFrom(const CRandCheckAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes keys = 1;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys() const;
  inline void set_keys(const ::std::string& value);
  inline void set_keys(const char* value);
  inline void set_keys(const void* value, size_t size);
  inline ::std::string* mutable_keys();
  inline ::std::string* release_keys();
  inline void set_allocated_keys(::std::string* keys);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CRandCheckAck)
 private:
  inline void set_has_keys();
  inline void clear_has_keys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CRandCheckAck* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPing : public ::google::protobuf::Message {
 public:
  CHeartPing();
  virtual ~CHeartPing();

  CHeartPing(const CHeartPing& from);

  inline CHeartPing& operator=(const CHeartPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPing& default_instance();

  void Swap(CHeartPing* other);

  // implements Message ----------------------------------------------

  CHeartPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPing& from);
  void MergeFrom(const CHeartPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CHeartPing)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CHeartPing* default_instance_;
};
// -------------------------------------------------------------------

class CHeartPingAck : public ::google::protobuf::Message {
 public:
  CHeartPingAck();
  virtual ~CHeartPingAck();

  CHeartPingAck(const CHeartPingAck& from);

  inline CHeartPingAck& operator=(const CHeartPingAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHeartPingAck& default_instance();

  void Swap(CHeartPingAck* other);

  // implements Message ----------------------------------------------

  CHeartPingAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHeartPingAck& from);
  void MergeFrom(const CHeartPingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline ::google::protobuf::int32 opt() const;
  inline void set_opt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CHeartPingAck)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CHeartPingAck* default_instance_;
};
// -------------------------------------------------------------------

class GMListRpt_gm : public ::google::protobuf::Message {
 public:
  GMListRpt_gm();
  virtual ~GMListRpt_gm();

  GMListRpt_gm(const GMListRpt_gm& from);

  inline GMListRpt_gm& operator=(const GMListRpt_gm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMListRpt_gm& default_instance();

  void Swap(GMListRpt_gm* other);

  // implements Message ----------------------------------------------

  GMListRpt_gm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMListRpt_gm& from);
  void MergeFrom(const GMListRpt_gm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gm_level = 2;
  inline bool has_gm_level() const;
  inline void clear_gm_level();
  static const int kGmLevelFieldNumber = 2;
  inline ::google::protobuf::int32 gm_level() const;
  inline void set_gm_level(::google::protobuf::int32 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.GMListRpt.gm)
 private:
  inline void set_has_gm_level();
  inline void clear_has_gm_level();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::google::protobuf::int32 gm_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static GMListRpt_gm* default_instance_;
};
// -------------------------------------------------------------------

class GMListRpt : public ::google::protobuf::Message {
 public:
  GMListRpt();
  virtual ~GMListRpt();

  GMListRpt(const GMListRpt& from);

  inline GMListRpt& operator=(const GMListRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMListRpt& default_instance();

  void Swap(GMListRpt* other);

  // implements Message ----------------------------------------------

  GMListRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMListRpt& from);
  void MergeFrom(const GMListRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GMListRpt_gm gm;

  // accessors -------------------------------------------------------

  // repeated .protoc.logindbs.GMListRpt.gm table = 1;
  inline int table_size() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::protoc::logindbs::GMListRpt_gm& table(int index) const;
  inline ::protoc::logindbs::GMListRpt_gm* mutable_table(int index);
  inline ::protoc::logindbs::GMListRpt_gm* add_table();
  inline const ::google::protobuf::RepeatedPtrField< ::protoc::logindbs::GMListRpt_gm >&
      table() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoc::logindbs::GMListRpt_gm >*
      mutable_table();

  // @@protoc_insertion_point(class_scope:protoc.logindbs.GMListRpt)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protoc::logindbs::GMListRpt_gm > table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static GMListRpt* default_instance_;
};
// -------------------------------------------------------------------

class AreaMaxOnlineNumberRpt : public ::google::protobuf::Message {
 public:
  AreaMaxOnlineNumberRpt();
  virtual ~AreaMaxOnlineNumberRpt();

  AreaMaxOnlineNumberRpt(const AreaMaxOnlineNumberRpt& from);

  inline AreaMaxOnlineNumberRpt& operator=(const AreaMaxOnlineNumberRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AreaMaxOnlineNumberRpt& default_instance();

  void Swap(AreaMaxOnlineNumberRpt* other);

  // implements Message ----------------------------------------------

  AreaMaxOnlineNumberRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AreaMaxOnlineNumberRpt& from);
  void MergeFrom(const AreaMaxOnlineNumberRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.AreaMaxOnlineNumberRpt)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static AreaMaxOnlineNumberRpt* default_instance_;
};
// -------------------------------------------------------------------

class CDBServerRpt : public ::google::protobuf::Message {
 public:
  CDBServerRpt();
  virtual ~CDBServerRpt();

  CDBServerRpt(const CDBServerRpt& from);

  inline CDBServerRpt& operator=(const CDBServerRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDBServerRpt& default_instance();

  void Swap(CDBServerRpt* other);

  // implements Message ----------------------------------------------

  CDBServerRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDBServerRpt& from);
  void MergeFrom(const CDBServerRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.CDBServerRpt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static CDBServerRpt* default_instance_;
};
// -------------------------------------------------------------------

class LDGetGM_ListReq : public ::google::protobuf::Message {
 public:
  LDGetGM_ListReq();
  virtual ~LDGetGM_ListReq();

  LDGetGM_ListReq(const LDGetGM_ListReq& from);

  inline LDGetGM_ListReq& operator=(const LDGetGM_ListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LDGetGM_ListReq& default_instance();

  void Swap(LDGetGM_ListReq* other);

  // implements Message ----------------------------------------------

  LDGetGM_ListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LDGetGM_ListReq& from);
  void MergeFrom(const LDGetGM_ListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string strDBID = 2;
  inline bool has_strdbid() const;
  inline void clear_strdbid();
  static const int kStrDBIDFieldNumber = 2;
  inline const ::std::string& strdbid() const;
  inline void set_strdbid(const ::std::string& value);
  inline void set_strdbid(const char* value);
  inline void set_strdbid(const char* value, size_t size);
  inline ::std::string* mutable_strdbid();
  inline ::std::string* release_strdbid();
  inline void set_allocated_strdbid(::std::string* strdbid);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.LDGetGM_ListReq)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_strdbid();
  inline void clear_has_strdbid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* strdbid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static LDGetGM_ListReq* default_instance_;
};
// -------------------------------------------------------------------

class LDGetGM_ListAck : public ::google::protobuf::Message {
 public:
  LDGetGM_ListAck();
  virtual ~LDGetGM_ListAck();

  LDGetGM_ListAck(const LDGetGM_ListAck& from);

  inline LDGetGM_ListAck& operator=(const LDGetGM_ListAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LDGetGM_ListAck& default_instance();

  void Swap(LDGetGM_ListAck* other);

  // implements Message ----------------------------------------------

  LDGetGM_ListAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LDGetGM_ListAck& from);
  void MergeFrom(const LDGetGM_ListAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string strDBID = 2;
  inline bool has_strdbid() const;
  inline void clear_strdbid();
  static const int kStrDBIDFieldNumber = 2;
  inline const ::std::string& strdbid() const;
  inline void set_strdbid(const ::std::string& value);
  inline void set_strdbid(const char* value);
  inline void set_strdbid(const char* value, size_t size);
  inline ::std::string* mutable_strdbid();
  inline ::std::string* release_strdbid();
  inline void set_allocated_strdbid(::std::string* strdbid);

  // optional int32 err_no = 3;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 3;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.LDGetGM_ListAck)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_strdbid();
  inline void clear_has_strdbid();
  inline void set_has_err_no();
  inline void clear_has_err_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* strdbid_;
  ::google::protobuf::int32 err_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static LDGetGM_ListAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginServerCloseNtf : public ::google::protobuf::Message {
 public:
  LoginServerCloseNtf();
  virtual ~LoginServerCloseNtf();

  LoginServerCloseNtf(const LoginServerCloseNtf& from);

  inline LoginServerCloseNtf& operator=(const LoginServerCloseNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginServerCloseNtf& default_instance();

  void Swap(LoginServerCloseNtf* other);

  // implements Message ----------------------------------------------

  LoginServerCloseNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginServerCloseNtf& from);
  void MergeFrom(const LoginServerCloseNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protoc.logindbs.LoginServerCloseNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static LoginServerCloseNtf* default_instance_;
};
// -------------------------------------------------------------------

class PlayerGetBaseDataComplete : public ::google::protobuf::Message {
 public:
  PlayerGetBaseDataComplete();
  virtual ~PlayerGetBaseDataComplete();

  PlayerGetBaseDataComplete(const PlayerGetBaseDataComplete& from);

  inline PlayerGetBaseDataComplete& operator=(const PlayerGetBaseDataComplete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerGetBaseDataComplete& default_instance();

  void Swap(PlayerGetBaseDataComplete* other);

  // implements Message ----------------------------------------------

  PlayerGetBaseDataComplete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerGetBaseDataComplete& from);
  void MergeFrom(const PlayerGetBaseDataComplete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.PlayerGetBaseDataComplete)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static PlayerGetBaseDataComplete* default_instance_;
};
// -------------------------------------------------------------------

class ClientCloseWhenWaitCheckInDB : public ::google::protobuf::Message {
 public:
  ClientCloseWhenWaitCheckInDB();
  virtual ~ClientCloseWhenWaitCheckInDB();

  ClientCloseWhenWaitCheckInDB(const ClientCloseWhenWaitCheckInDB& from);

  inline ClientCloseWhenWaitCheckInDB& operator=(const ClientCloseWhenWaitCheckInDB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCloseWhenWaitCheckInDB& default_instance();

  void Swap(ClientCloseWhenWaitCheckInDB* other);

  // implements Message ----------------------------------------------

  ClientCloseWhenWaitCheckInDB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCloseWhenWaitCheckInDB& from);
  void MergeFrom(const ClientCloseWhenWaitCheckInDB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.ClientCloseWhenWaitCheckInDB)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static ClientCloseWhenWaitCheckInDB* default_instance_;
};
// -------------------------------------------------------------------

class get_login_key_req : public ::google::protobuf::Message {
 public:
  get_login_key_req();
  virtual ~get_login_key_req();

  get_login_key_req(const get_login_key_req& from);

  inline get_login_key_req& operator=(const get_login_key_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_login_key_req& default_instance();

  void Swap(get_login_key_req* other);

  // implements Message ----------------------------------------------

  get_login_key_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_login_key_req& from);
  void MergeFrom(const get_login_key_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string gsid = 2;
  inline bool has_gsid() const;
  inline void clear_gsid();
  static const int kGsidFieldNumber = 2;
  inline const ::std::string& gsid() const;
  inline void set_gsid(const ::std::string& value);
  inline void set_gsid(const char* value);
  inline void set_gsid(const char* value, size_t size);
  inline ::std::string* mutable_gsid();
  inline ::std::string* release_gsid();
  inline void set_allocated_gsid(::std::string* gsid);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.get_login_key_req)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gsid();
  inline void clear_has_gsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* gsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static get_login_key_req* default_instance_;
};
// -------------------------------------------------------------------

class get_login_key_ack : public ::google::protobuf::Message {
 public:
  get_login_key_ack();
  virtual ~get_login_key_ack();

  get_login_key_ack(const get_login_key_ack& from);

  inline get_login_key_ack& operator=(const get_login_key_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_login_key_ack& default_instance();

  void Swap(get_login_key_ack* other);

  // implements Message ----------------------------------------------

  get_login_key_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_login_key_ack& from);
  void MergeFrom(const get_login_key_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string gsid = 2;
  inline bool has_gsid() const;
  inline void clear_gsid();
  static const int kGsidFieldNumber = 2;
  inline const ::std::string& gsid() const;
  inline void set_gsid(const ::std::string& value);
  inline void set_gsid(const char* value);
  inline void set_gsid(const char* value, size_t size);
  inline ::std::string* mutable_gsid();
  inline ::std::string* release_gsid();
  inline void set_allocated_gsid(::std::string* gsid);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional int32 leave_time = 4;
  inline bool has_leave_time() const;
  inline void clear_leave_time();
  static const int kLeaveTimeFieldNumber = 4;
  inline ::google::protobuf::int32 leave_time() const;
  inline void set_leave_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.get_login_key_ack)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gsid();
  inline void clear_has_gsid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_leave_time();
  inline void clear_has_leave_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerid_;
  ::std::string* gsid_;
  ::std::string* key_;
  ::google::protobuf::int32 leave_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static get_login_key_ack* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFastAttackBlackAccountRpt : public ::google::protobuf::Message {
 public:
  UpdateFastAttackBlackAccountRpt();
  virtual ~UpdateFastAttackBlackAccountRpt();

  UpdateFastAttackBlackAccountRpt(const UpdateFastAttackBlackAccountRpt& from);

  inline UpdateFastAttackBlackAccountRpt& operator=(const UpdateFastAttackBlackAccountRpt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFastAttackBlackAccountRpt& default_instance();

  void Swap(UpdateFastAttackBlackAccountRpt* other);

  // implements Message ----------------------------------------------

  UpdateFastAttackBlackAccountRpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFastAttackBlackAccountRpt& from);
  void MergeFrom(const UpdateFastAttackBlackAccountRpt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 attack_value = 2;
  inline bool has_attack_value() const;
  inline void clear_attack_value();
  static const int kAttackValueFieldNumber = 2;
  inline ::google::protobuf::uint32 attack_value() const;
  inline void set_attack_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoc.logindbs.UpdateFastAttackBlackAccountRpt)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_attack_value();
  inline void clear_has_attack_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::uint32 attack_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2edbserver_2eproto();
  friend void protobuf_AssignDesc_login_2edbserver_2eproto();
  friend void protobuf_ShutdownFile_login_2edbserver_2eproto();

  void InitAsDefaultInstance();
  static UpdateFastAttackBlackAccountRpt* default_instance_;
};
// ===================================================================


// ===================================================================

// CLoginServerRpt

// optional string id = 1;
inline bool CLoginServerRpt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLoginServerRpt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLoginServerRpt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLoginServerRpt::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CLoginServerRpt::id() const {
  return *id_;
}
inline void CLoginServerRpt::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CLoginServerRpt::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CLoginServerRpt::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CLoginServerRpt::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CLoginServerRpt::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CLoginServerRpt::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CLoginServerRpt::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLoginServerRpt::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLoginServerRpt::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLoginServerRpt::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CLoginServerRpt::name() const {
  return *name_;
}
inline void CLoginServerRpt::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CLoginServerRpt::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CLoginServerRpt::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CLoginServerRpt::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CLoginServerRpt::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CLoginServerRpt::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 3;
inline bool CLoginServerRpt::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CLoginServerRpt::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CLoginServerRpt::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CLoginServerRpt::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CLoginServerRpt::key() const {
  return *key_;
}
inline void CLoginServerRpt::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CLoginServerRpt::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CLoginServerRpt::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CLoginServerRpt::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CLoginServerRpt::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CLoginServerRpt::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CUserCheckInDBServerReq

// optional uint32 transID = 1;
inline bool CUserCheckInDBServerReq::has_transid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserCheckInDBServerReq::set_has_transid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserCheckInDBServerReq::clear_has_transid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserCheckInDBServerReq::clear_transid() {
  transid_ = 0u;
  clear_has_transid();
}
inline ::google::protobuf::uint32 CUserCheckInDBServerReq::transid() const {
  return transid_;
}
inline void CUserCheckInDBServerReq::set_transid(::google::protobuf::uint32 value) {
  set_has_transid();
  transid_ = value;
}

// optional uint64 playerid = 2;
inline bool CUserCheckInDBServerReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserCheckInDBServerReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserCheckInDBServerReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserCheckInDBServerReq::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 CUserCheckInDBServerReq::playerid() const {
  return playerid_;
}
inline void CUserCheckInDBServerReq::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string account = 3;
inline bool CUserCheckInDBServerReq::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserCheckInDBServerReq::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserCheckInDBServerReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserCheckInDBServerReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CUserCheckInDBServerReq::account() const {
  return *account_;
}
inline void CUserCheckInDBServerReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CUserCheckInDBServerReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CUserCheckInDBServerReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CUserCheckInDBServerReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CUserCheckInDBServerReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CUserCheckInDBServerReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 area_id = 4;
inline bool CUserCheckInDBServerReq::has_area_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserCheckInDBServerReq::set_has_area_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserCheckInDBServerReq::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserCheckInDBServerReq::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 CUserCheckInDBServerReq::area_id() const {
  return area_id_;
}
inline void CUserCheckInDBServerReq::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional int32 platform_id = 5;
inline bool CUserCheckInDBServerReq::has_platform_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserCheckInDBServerReq::set_has_platform_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserCheckInDBServerReq::clear_has_platform_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserCheckInDBServerReq::clear_platform_id() {
  platform_id_ = 0;
  clear_has_platform_id();
}
inline ::google::protobuf::int32 CUserCheckInDBServerReq::platform_id() const {
  return platform_id_;
}
inline void CUserCheckInDBServerReq::set_platform_id(::google::protobuf::int32 value) {
  set_has_platform_id();
  platform_id_ = value;
}

// -------------------------------------------------------------------

// CUserCheckInDBServerAck

// optional uint32 transID = 1;
inline bool CUserCheckInDBServerAck::has_transid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_transid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CUserCheckInDBServerAck::clear_has_transid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CUserCheckInDBServerAck::clear_transid() {
  transid_ = 0u;
  clear_has_transid();
}
inline ::google::protobuf::uint32 CUserCheckInDBServerAck::transid() const {
  return transid_;
}
inline void CUserCheckInDBServerAck::set_transid(::google::protobuf::uint32 value) {
  set_has_transid();
  transid_ = value;
}

// optional uint64 playerid = 2;
inline bool CUserCheckInDBServerAck::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CUserCheckInDBServerAck::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CUserCheckInDBServerAck::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 CUserCheckInDBServerAck::playerid() const {
  return playerid_;
}
inline void CUserCheckInDBServerAck::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional int32 err_no = 3;
inline bool CUserCheckInDBServerAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CUserCheckInDBServerAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CUserCheckInDBServerAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 CUserCheckInDBServerAck::err_no() const {
  return err_no_;
}
inline void CUserCheckInDBServerAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string gate_ip = 4;
inline bool CUserCheckInDBServerAck::has_gate_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_gate_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CUserCheckInDBServerAck::clear_has_gate_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CUserCheckInDBServerAck::clear_gate_ip() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    gate_ip_->clear();
  }
  clear_has_gate_ip();
}
inline const ::std::string& CUserCheckInDBServerAck::gate_ip() const {
  return *gate_ip_;
}
inline void CUserCheckInDBServerAck::set_gate_ip(const ::std::string& value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void CUserCheckInDBServerAck::set_gate_ip(const char* value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void CUserCheckInDBServerAck::set_gate_ip(const char* value, size_t size) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CUserCheckInDBServerAck::mutable_gate_ip() {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  return gate_ip_;
}
inline ::std::string* CUserCheckInDBServerAck::release_gate_ip() {
  clear_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_ip_;
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CUserCheckInDBServerAck::set_allocated_gate_ip(::std::string* gate_ip) {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  if (gate_ip) {
    set_has_gate_ip();
    gate_ip_ = gate_ip;
  } else {
    clear_has_gate_ip();
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gate_port = 5;
inline bool CUserCheckInDBServerAck::has_gate_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_gate_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CUserCheckInDBServerAck::clear_has_gate_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CUserCheckInDBServerAck::clear_gate_port() {
  gate_port_ = 0u;
  clear_has_gate_port();
}
inline ::google::protobuf::uint32 CUserCheckInDBServerAck::gate_port() const {
  return gate_port_;
}
inline void CUserCheckInDBServerAck::set_gate_port(::google::protobuf::uint32 value) {
  set_has_gate_port();
  gate_port_ = value;
}

// optional int32 gate_key = 6;
inline bool CUserCheckInDBServerAck::has_gate_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_gate_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CUserCheckInDBServerAck::clear_has_gate_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CUserCheckInDBServerAck::clear_gate_key() {
  gate_key_ = 0;
  clear_has_gate_key();
}
inline ::google::protobuf::int32 CUserCheckInDBServerAck::gate_key() const {
  return gate_key_;
}
inline void CUserCheckInDBServerAck::set_gate_key(::google::protobuf::int32 value) {
  set_has_gate_key();
  gate_key_ = value;
}

// optional uint32 sessionid = 7;
inline bool CUserCheckInDBServerAck::has_sessionid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CUserCheckInDBServerAck::set_has_sessionid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CUserCheckInDBServerAck::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CUserCheckInDBServerAck::clear_sessionid() {
  sessionid_ = 0u;
  clear_has_sessionid();
}
inline ::google::protobuf::uint32 CUserCheckInDBServerAck::sessionid() const {
  return sessionid_;
}
inline void CUserCheckInDBServerAck::set_sessionid(::google::protobuf::uint32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// CRandCheckReq

// optional bytes randkeys = 1;
inline bool CRandCheckReq::has_randkeys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckReq::set_has_randkeys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckReq::clear_has_randkeys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckReq::clear_randkeys() {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    randkeys_->clear();
  }
  clear_has_randkeys();
}
inline const ::std::string& CRandCheckReq::randkeys() const {
  return *randkeys_;
}
inline void CRandCheckReq::set_randkeys(const ::std::string& value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const char* value) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(value);
}
inline void CRandCheckReq::set_randkeys(const void* value, size_t size) {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  randkeys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckReq::mutable_randkeys() {
  set_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    randkeys_ = new ::std::string;
  }
  return randkeys_;
}
inline ::std::string* CRandCheckReq::release_randkeys() {
  clear_has_randkeys();
  if (randkeys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randkeys_;
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckReq::set_allocated_randkeys(::std::string* randkeys) {
  if (randkeys_ != &::google::protobuf::internal::kEmptyString) {
    delete randkeys_;
  }
  if (randkeys) {
    set_has_randkeys();
    randkeys_ = randkeys;
  } else {
    clear_has_randkeys();
    randkeys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRandCheckAck

// optional bytes keys = 1;
inline bool CRandCheckAck::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRandCheckAck::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRandCheckAck::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRandCheckAck::clear_keys() {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    keys_->clear();
  }
  clear_has_keys();
}
inline const ::std::string& CRandCheckAck::keys() const {
  return *keys_;
}
inline void CRandCheckAck::set_keys(const ::std::string& value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const char* value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
}
inline void CRandCheckAck::set_keys(const void* value, size_t size) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  keys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRandCheckAck::mutable_keys() {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    keys_ = new ::std::string;
  }
  return keys_;
}
inline ::std::string* CRandCheckAck::release_keys() {
  clear_has_keys();
  if (keys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keys_;
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRandCheckAck::set_allocated_keys(::std::string* keys) {
  if (keys_ != &::google::protobuf::internal::kEmptyString) {
    delete keys_;
  }
  if (keys) {
    set_has_keys();
    keys_ = keys;
  } else {
    clear_has_keys();
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CHeartPing

// optional int32 opt = 1;
inline bool CHeartPing::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPing::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPing::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPing::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPing::opt() const {
  return opt_;
}
inline void CHeartPing::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// CHeartPingAck

// optional int32 opt = 1;
inline bool CHeartPingAck::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHeartPingAck::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHeartPingAck::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHeartPingAck::clear_opt() {
  opt_ = 0;
  clear_has_opt();
}
inline ::google::protobuf::int32 CHeartPingAck::opt() const {
  return opt_;
}
inline void CHeartPingAck::set_opt(::google::protobuf::int32 value) {
  set_has_opt();
  opt_ = value;
}

// -------------------------------------------------------------------

// GMListRpt_gm

// optional int32 gm_level = 2;
inline bool GMListRpt_gm::has_gm_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMListRpt_gm::set_has_gm_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMListRpt_gm::clear_has_gm_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMListRpt_gm::clear_gm_level() {
  gm_level_ = 0;
  clear_has_gm_level();
}
inline ::google::protobuf::int32 GMListRpt_gm::gm_level() const {
  return gm_level_;
}
inline void GMListRpt_gm::set_gm_level(::google::protobuf::int32 value) {
  set_has_gm_level();
  gm_level_ = value;
}

// optional string account = 3;
inline bool GMListRpt_gm::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMListRpt_gm::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMListRpt_gm::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMListRpt_gm::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& GMListRpt_gm::account() const {
  return *account_;
}
inline void GMListRpt_gm::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GMListRpt_gm::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GMListRpt_gm::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMListRpt_gm::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* GMListRpt_gm::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMListRpt_gm::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool GMListRpt_gm::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMListRpt_gm::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMListRpt_gm::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMListRpt_gm::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GMListRpt_gm::password() const {
  return *password_;
}
inline void GMListRpt_gm::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GMListRpt_gm::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GMListRpt_gm::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMListRpt_gm::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GMListRpt_gm::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMListRpt_gm::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GMListRpt

// repeated .protoc.logindbs.GMListRpt.gm table = 1;
inline int GMListRpt::table_size() const {
  return table_.size();
}
inline void GMListRpt::clear_table() {
  table_.Clear();
}
inline const ::protoc::logindbs::GMListRpt_gm& GMListRpt::table(int index) const {
  return table_.Get(index);
}
inline ::protoc::logindbs::GMListRpt_gm* GMListRpt::mutable_table(int index) {
  return table_.Mutable(index);
}
inline ::protoc::logindbs::GMListRpt_gm* GMListRpt::add_table() {
  return table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoc::logindbs::GMListRpt_gm >&
GMListRpt::table() const {
  return table_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoc::logindbs::GMListRpt_gm >*
GMListRpt::mutable_table() {
  return &table_;
}

// -------------------------------------------------------------------

// AreaMaxOnlineNumberRpt

// optional int32 number = 1;
inline bool AreaMaxOnlineNumberRpt::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AreaMaxOnlineNumberRpt::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AreaMaxOnlineNumberRpt::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AreaMaxOnlineNumberRpt::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 AreaMaxOnlineNumberRpt::number() const {
  return number_;
}
inline void AreaMaxOnlineNumberRpt::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// CDBServerRpt

// optional string id = 1;
inline bool CDBServerRpt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDBServerRpt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDBServerRpt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDBServerRpt::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CDBServerRpt::id() const {
  return *id_;
}
inline void CDBServerRpt::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CDBServerRpt::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CDBServerRpt::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDBServerRpt::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CDBServerRpt::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDBServerRpt::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool CDBServerRpt::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDBServerRpt::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDBServerRpt::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDBServerRpt::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CDBServerRpt::name() const {
  return *name_;
}
inline void CDBServerRpt::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CDBServerRpt::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CDBServerRpt::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDBServerRpt::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CDBServerRpt::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDBServerRpt::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 number = 3;
inline bool CDBServerRpt::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDBServerRpt::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDBServerRpt::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDBServerRpt::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 CDBServerRpt::number() const {
  return number_;
}
inline void CDBServerRpt::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// LDGetGM_ListReq

// optional uint64 playerid = 1;
inline bool LDGetGM_ListReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LDGetGM_ListReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LDGetGM_ListReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LDGetGM_ListReq::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 LDGetGM_ListReq::playerid() const {
  return playerid_;
}
inline void LDGetGM_ListReq::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string strDBID = 2;
inline bool LDGetGM_ListReq::has_strdbid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LDGetGM_ListReq::set_has_strdbid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LDGetGM_ListReq::clear_has_strdbid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LDGetGM_ListReq::clear_strdbid() {
  if (strdbid_ != &::google::protobuf::internal::kEmptyString) {
    strdbid_->clear();
  }
  clear_has_strdbid();
}
inline const ::std::string& LDGetGM_ListReq::strdbid() const {
  return *strdbid_;
}
inline void LDGetGM_ListReq::set_strdbid(const ::std::string& value) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(value);
}
inline void LDGetGM_ListReq::set_strdbid(const char* value) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(value);
}
inline void LDGetGM_ListReq::set_strdbid(const char* value, size_t size) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LDGetGM_ListReq::mutable_strdbid() {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  return strdbid_;
}
inline ::std::string* LDGetGM_ListReq::release_strdbid() {
  clear_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdbid_;
    strdbid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LDGetGM_ListReq::set_allocated_strdbid(::std::string* strdbid) {
  if (strdbid_ != &::google::protobuf::internal::kEmptyString) {
    delete strdbid_;
  }
  if (strdbid) {
    set_has_strdbid();
    strdbid_ = strdbid;
  } else {
    clear_has_strdbid();
    strdbid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LDGetGM_ListAck

// optional uint64 playerid = 1;
inline bool LDGetGM_ListAck::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LDGetGM_ListAck::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LDGetGM_ListAck::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LDGetGM_ListAck::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 LDGetGM_ListAck::playerid() const {
  return playerid_;
}
inline void LDGetGM_ListAck::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string strDBID = 2;
inline bool LDGetGM_ListAck::has_strdbid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LDGetGM_ListAck::set_has_strdbid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LDGetGM_ListAck::clear_has_strdbid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LDGetGM_ListAck::clear_strdbid() {
  if (strdbid_ != &::google::protobuf::internal::kEmptyString) {
    strdbid_->clear();
  }
  clear_has_strdbid();
}
inline const ::std::string& LDGetGM_ListAck::strdbid() const {
  return *strdbid_;
}
inline void LDGetGM_ListAck::set_strdbid(const ::std::string& value) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(value);
}
inline void LDGetGM_ListAck::set_strdbid(const char* value) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(value);
}
inline void LDGetGM_ListAck::set_strdbid(const char* value, size_t size) {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  strdbid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LDGetGM_ListAck::mutable_strdbid() {
  set_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    strdbid_ = new ::std::string;
  }
  return strdbid_;
}
inline ::std::string* LDGetGM_ListAck::release_strdbid() {
  clear_has_strdbid();
  if (strdbid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdbid_;
    strdbid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LDGetGM_ListAck::set_allocated_strdbid(::std::string* strdbid) {
  if (strdbid_ != &::google::protobuf::internal::kEmptyString) {
    delete strdbid_;
  }
  if (strdbid) {
    set_has_strdbid();
    strdbid_ = strdbid;
  } else {
    clear_has_strdbid();
    strdbid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 err_no = 3;
inline bool LDGetGM_ListAck::has_err_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LDGetGM_ListAck::set_has_err_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LDGetGM_ListAck::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LDGetGM_ListAck::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 LDGetGM_ListAck::err_no() const {
  return err_no_;
}
inline void LDGetGM_ListAck::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// -------------------------------------------------------------------

// LoginServerCloseNtf

// -------------------------------------------------------------------

// PlayerGetBaseDataComplete

// optional string account = 1;
inline bool PlayerGetBaseDataComplete::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerGetBaseDataComplete::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerGetBaseDataComplete::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerGetBaseDataComplete::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& PlayerGetBaseDataComplete::account() const {
  return *account_;
}
inline void PlayerGetBaseDataComplete::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void PlayerGetBaseDataComplete::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void PlayerGetBaseDataComplete::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGetBaseDataComplete::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* PlayerGetBaseDataComplete::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGetBaseDataComplete::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientCloseWhenWaitCheckInDB

// optional uint64 playerid = 1;
inline bool ClientCloseWhenWaitCheckInDB::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCloseWhenWaitCheckInDB::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCloseWhenWaitCheckInDB::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCloseWhenWaitCheckInDB::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 ClientCloseWhenWaitCheckInDB::playerid() const {
  return playerid_;
}
inline void ClientCloseWhenWaitCheckInDB::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// get_login_key_req

// optional uint64 playerid = 1;
inline bool get_login_key_req::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_login_key_req::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_login_key_req::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_login_key_req::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 get_login_key_req::playerid() const {
  return playerid_;
}
inline void get_login_key_req::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string gsid = 2;
inline bool get_login_key_req::has_gsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_login_key_req::set_has_gsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_login_key_req::clear_has_gsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_login_key_req::clear_gsid() {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    gsid_->clear();
  }
  clear_has_gsid();
}
inline const ::std::string& get_login_key_req::gsid() const {
  return *gsid_;
}
inline void get_login_key_req::set_gsid(const ::std::string& value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void get_login_key_req::set_gsid(const char* value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void get_login_key_req::set_gsid(const char* value, size_t size) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_login_key_req::mutable_gsid() {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  return gsid_;
}
inline ::std::string* get_login_key_req::release_gsid() {
  clear_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gsid_;
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void get_login_key_req::set_allocated_gsid(::std::string* gsid) {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    delete gsid_;
  }
  if (gsid) {
    set_has_gsid();
    gsid_ = gsid;
  } else {
    clear_has_gsid();
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// get_login_key_ack

// optional uint64 playerid = 1;
inline bool get_login_key_ack::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_login_key_ack::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_login_key_ack::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_login_key_ack::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 get_login_key_ack::playerid() const {
  return playerid_;
}
inline void get_login_key_ack::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string gsid = 2;
inline bool get_login_key_ack::has_gsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_login_key_ack::set_has_gsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_login_key_ack::clear_has_gsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_login_key_ack::clear_gsid() {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    gsid_->clear();
  }
  clear_has_gsid();
}
inline const ::std::string& get_login_key_ack::gsid() const {
  return *gsid_;
}
inline void get_login_key_ack::set_gsid(const ::std::string& value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void get_login_key_ack::set_gsid(const char* value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void get_login_key_ack::set_gsid(const char* value, size_t size) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_login_key_ack::mutable_gsid() {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  return gsid_;
}
inline ::std::string* get_login_key_ack::release_gsid() {
  clear_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gsid_;
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void get_login_key_ack::set_allocated_gsid(::std::string* gsid) {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    delete gsid_;
  }
  if (gsid) {
    set_has_gsid();
    gsid_ = gsid;
  } else {
    clear_has_gsid();
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 3;
inline bool get_login_key_ack::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void get_login_key_ack::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void get_login_key_ack::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void get_login_key_ack::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& get_login_key_ack::key() const {
  return *key_;
}
inline void get_login_key_ack::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void get_login_key_ack::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void get_login_key_ack::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_login_key_ack::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* get_login_key_ack::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void get_login_key_ack::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 leave_time = 4;
inline bool get_login_key_ack::has_leave_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void get_login_key_ack::set_has_leave_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void get_login_key_ack::clear_has_leave_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void get_login_key_ack::clear_leave_time() {
  leave_time_ = 0;
  clear_has_leave_time();
}
inline ::google::protobuf::int32 get_login_key_ack::leave_time() const {
  return leave_time_;
}
inline void get_login_key_ack::set_leave_time(::google::protobuf::int32 value) {
  set_has_leave_time();
  leave_time_ = value;
}

// -------------------------------------------------------------------

// UpdateFastAttackBlackAccountRpt

// optional string account = 1;
inline bool UpdateFastAttackBlackAccountRpt::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFastAttackBlackAccountRpt::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFastAttackBlackAccountRpt::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFastAttackBlackAccountRpt::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UpdateFastAttackBlackAccountRpt::account() const {
  return *account_;
}
inline void UpdateFastAttackBlackAccountRpt::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UpdateFastAttackBlackAccountRpt::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UpdateFastAttackBlackAccountRpt::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateFastAttackBlackAccountRpt::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* UpdateFastAttackBlackAccountRpt::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateFastAttackBlackAccountRpt::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 attack_value = 2;
inline bool UpdateFastAttackBlackAccountRpt::has_attack_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateFastAttackBlackAccountRpt::set_has_attack_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateFastAttackBlackAccountRpt::clear_has_attack_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateFastAttackBlackAccountRpt::clear_attack_value() {
  attack_value_ = 0u;
  clear_has_attack_value();
}
inline ::google::protobuf::uint32 UpdateFastAttackBlackAccountRpt::attack_value() const {
  return attack_value_;
}
inline void UpdateFastAttackBlackAccountRpt::set_attack_value(::google::protobuf::uint32 value) {
  set_has_attack_value();
  attack_value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace logindbs
}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login_2edbserver_2eproto__INCLUDED
